(() => {
  // src/shared/lt-data-core.user.js
  (function() {
    "use strict";
    const root = typeof unsafeWindow !== "undefined" ? unsafeWindow : window;
    function findDC(env = typeof unsafeWindow !== "undefined" ? unsafeWindow : window) {
      try {
        if (typeof lt !== "undefined" && lt?.core?.data) return { dc: lt.core.data, host: env };
      } catch {
      }
      try {
        if (env.lt?.core?.data) return { dc: env.lt.core.data, host: env };
      } catch {
      }
      for (let i = 0; i < env.frames.length; i++) {
        try {
          const r = findDC(env.frames[i]);
          if (r) return r;
        } catch {
        }
      }
      return null;
    }
    function install() {
      const ROOT = typeof unsafeWindow !== "undefined" ? unsafeWindow : window;
      const LT = typeof lt !== "undefined" ? lt : ROOT.lt = ROOT.lt || {};
      const CORE = LT.core = LT.core || {};
      let DC = CORE.data;
      if (!DC) {
        DC = CORE.data = {};
      }
      if (!DC.createDataContext) {
        DC.createDataContext = function createDataContext({ ns, scopeKey, persist = "session", ttlMs = null }) {
          const storage = persist === "local" ? ROOT.localStorage : ROOT.sessionStorage;
          const prefix = `lt:${ns}:${scopeKey}:`;
          const headerKey = `${prefix}header`;
          return {
            // Flat repo factory: we ignore RepoCtor and return a simple header repo
            makeRepo() {
              const api = {
                async get() {
                  try {
                    const s = storage.getItem(headerKey);
                    return s ? JSON.parse(s) : null;
                  } catch {
                    return null;
                  }
                },
                async getHeader() {
                  return this.get();
                },
                async patchHeader(patch) {
                  const cur = await this.get() || {};
                  const next = Object.assign({}, cur, patch || {});
                  try {
                    storage.setItem(headerKey, JSON.stringify(next));
                  } catch {
                  }
                  return next;
                },
                async clear() {
                  try {
                    storage.removeItem(headerKey);
                  } catch {
                  }
                },
                async ensureFromLegacyIfMissing() {
                }
              };
              return api;
            }
          };
        };
      }
      if (!DC.makeFlatScopedRepo) {
        let hashScope = function(s) {
          let h = 2166136261 >>> 0;
          for (let i = 0; i < s.length; i++) {
            h ^= s.charCodeAt(i);
            h = Math.imul(h, 16777619) >>> 0;
          }
          return h >>> 0;
        }, makeFlatScopedRepo = function({ ns, entity = "quote", persist = "session", ttlMs = null, legacyEntity = null } = {}) {
          function use(scopeKey) {
            const key = typeof scopeKey === "string" ? hashScope(scopeKey) : Number(scopeKey);
            if (!Number.isFinite(key) || key <= 0) throw new Error("Invalid scopeKey");
            const ctx = DC.createDataContext({ ns, scopeKey: key, persist, ttlMs });
            const repo = ctx.makeRepo(function FlatRepo() {
            });
            return { ctx, repo };
          }
          return { use, FlatRepo: function FlatRepo() {
          }, opts: { ns, entity, persist, ttlMs, legacyEntity } };
        };
        Object.defineProperty(DC, "makeFlatScopedRepo", { value: makeFlatScopedRepo, configurable: true, writable: true });
      }
      try {
      } catch {
      }
      return true;
    }
    install();
  })();
})();
;(function(g){try{if(typeof LTDataCore!=='undefined'){g.LTDataCore=LTDataCore;}}catch(e){}})(typeof unsafeWindow!=='undefined'?unsafeWindow:window);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vdG0tc2NyaXB0cy9zcmMvc2hhcmVkL2x0LWRhdGEtY29yZS51c2VyLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyA9PVVzZXJTY3JpcHQ9PVxuLy8gQG5hbWUgICAgICAgICBsdC1kYXRhLWNvcmVcbi8vIEBuYW1lc3BhY2UgICAgbHRcbi8vIEB2ZXJzaW9uICAgICAgMy45LjIzXG4vLyBAZGVzY3JpcHRpb24gIENvcmUgZGF0YTogYWRkIG1ha2VGbGF0U2NvcGVkUmVwbyAoZmxhdCB7aGVhZGVyLGxpbmVzfSkgb250byBsdC5jb3JlLmRhdGEsIHdhaXRpbmcgZm9yIERDIHRvIGxvYWRcbi8vIEBtYXRjaCAgICAgICAgaHR0cHM6Ly8qL1NhbGVzQW5kQ1JNLypcbi8vIEBncmFudCAgICAgICAgbm9uZVxuLy8gQHJ1bi1hdCAgICAgICBkb2N1bWVudC1zdGFydFxuLy8gPT0vVXNlclNjcmlwdFxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgY29uc3Qgcm9vdCA9ICh0eXBlb2YgdW5zYWZlV2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB1bnNhZmVXaW5kb3cgOiB3aW5kb3c7XG5cbiAgICAvLyBMb2NhdGUgbHQuY29yZS5kYXRhIGZyb20gZWl0aGVyIHRoZSBzYW5kYm94IGBsdGAgKHZpYSBAcmVxdWlyZSBsdC1jb3JlKSBvciBhbnkgc2FtZS1vcmlnaW4gZnJhbWVcbiAgICBmdW5jdGlvbiBmaW5kREMoZW52ID0gKHR5cGVvZiB1bnNhZmVXaW5kb3cgIT09ICd1bmRlZmluZWQnID8gdW5zYWZlV2luZG93IDogd2luZG93KSkge1xuICAgICAgICAvLyAxKSBUTSBzYW5kYm94IHZhcmlhYmxlIHByb3ZpZGVkIGJ5IGx0LWNvcmUudXNlci5qc1xuICAgICAgICB0cnkgeyBpZiAodHlwZW9mIGx0ICE9PSAndW5kZWZpbmVkJyAmJiBsdD8uY29yZT8uZGF0YSkgcmV0dXJuIHsgZGM6IGx0LmNvcmUuZGF0YSwgaG9zdDogZW52IH07IH0gY2F0Y2ggeyB9XG4gICAgICAgIC8vIDIpIFBhZ2Ugd2luZG93XG4gICAgICAgIHRyeSB7IGlmIChlbnYubHQ/LmNvcmU/LmRhdGEpIHJldHVybiB7IGRjOiBlbnYubHQuY29yZS5kYXRhLCBob3N0OiBlbnYgfTsgfSBjYXRjaCB7IH1cbiAgICAgICAgLy8gMykgU2FtZS1vcmlnaW4gc3ViZnJhbWVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW52LmZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHsgY29uc3QgciA9IGZpbmREQyhlbnYuZnJhbWVzW2ldKTsgaWYgKHIpIHJldHVybiByOyB9IGNhdGNoIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgICBjb25zdCBST09UID0gKHR5cGVvZiB1bnNhZmVXaW5kb3cgIT09ICd1bmRlZmluZWQnID8gdW5zYWZlV2luZG93IDogd2luZG93KTtcblxuICAgICAgICAvLyBQcmVmZXIgdGhlIFRNIHNhbmRib3ggbHQgaWYgcHJlc2VudDsgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byBwYWdlIHdpbmRvd1xuICAgICAgICBjb25zdCBMVCA9ICh0eXBlb2YgbHQgIT09ICd1bmRlZmluZWQnKSA/IGx0IDogKFJPT1QubHQgPSBST09ULmx0IHx8IHt9KTtcbiAgICAgICAgY29uc3QgQ09SRSA9IChMVC5jb3JlID0gTFQuY29yZSB8fCB7fSk7XG5cbiAgICAgICAgLy8gSWYgUGxleCBoYXNuJ3QgcHJvdmlkZWQgYSBkYXRhIGNvcmUsIGNyZWF0ZSBhIHRpbnkgc2hpbVxuICAgICAgICBsZXQgREMgPSBDT1JFLmRhdGE7XG4gICAgICAgIGlmICghREMpIHtcbiAgICAgICAgICAgIERDID0gQ09SRS5kYXRhID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm92aWRlIGEgbWluaW1hbCBjcmVhdGVEYXRhQ29udGV4dCBpZiBtaXNzaW5nIChzZXNzaW9uU3RvcmFnZS1iYWNrZWQpXG4gICAgICAgIGlmICghREMuY3JlYXRlRGF0YUNvbnRleHQpIHtcbiAgICAgICAgICAgIERDLmNyZWF0ZURhdGFDb250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQoeyBucywgc2NvcGVLZXksIHBlcnNpc3QgPSAnc2Vzc2lvbicsIHR0bE1zID0gbnVsbCB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHBlcnNpc3QgPT09ICdsb2NhbCcgPyBST09ULmxvY2FsU3RvcmFnZSA6IFJPT1Quc2Vzc2lvblN0b3JhZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYGx0OiR7bnN9OiR7c2NvcGVLZXl9OmA7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyS2V5ID0gYCR7cHJlZml4fWhlYWRlcmA7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBGbGF0IHJlcG8gZmFjdG9yeTogd2UgaWdub3JlIFJlcG9DdG9yIGFuZCByZXR1cm4gYSBzaW1wbGUgaGVhZGVyIHJlcG9cbiAgICAgICAgICAgICAgICAgICAgbWFrZVJlcG8oLyogUmVwb0N0b3IgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYyBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7IGNvbnN0IHMgPSBzdG9yYWdlLmdldEl0ZW0oaGVhZGVyS2V5KTsgcmV0dXJuIHMgPyBKU09OLnBhcnNlKHMpIDogbnVsbDsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYyBnZXRIZWFkZXIoKSB7IHJldHVybiB0aGlzLmdldCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jIHBhdGNoSGVhZGVyKHBhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IChhd2FpdCB0aGlzLmdldCgpKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IE9iamVjdC5hc3NpZ24oe30sIGN1ciwgcGF0Y2ggfHwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgeyBzdG9yYWdlLnNldEl0ZW0oaGVhZGVyS2V5LCBKU09OLnN0cmluZ2lmeShuZXh0KSk7IH0gY2F0Y2ggeyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgY2xlYXIoKSB7IHRyeSB7IHN0b3JhZ2UucmVtb3ZlSXRlbShoZWFkZXJLZXkpOyB9IGNhdGNoIHsgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jIGVuc3VyZUZyb21MZWdhY3lJZk1pc3NpbmcoKSB7IC8qIG5vLW9wIGZvciBzaGltICovIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdHRhY2ggb3VyIGZsYXQtc2NvcGVkIGZhY3RvcnkgaWYgbWlzc2luZ1xuICAgICAgICBpZiAoIURDLm1ha2VGbGF0U2NvcGVkUmVwbykge1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzaFNjb3BlKHMpIHtcbiAgICAgICAgICAgICAgICAvLyBGTlYtMWEgMzItYml0XG4gICAgICAgICAgICAgICAgbGV0IGggPSAweDgxMWM5ZGM1ID4+PiAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBoIF49IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaCA9IE1hdGguaW11bChoLCAweDAxMDAwMTkzKSA+Pj4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGggPj4+IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1ha2VGbGF0U2NvcGVkUmVwbyh7IG5zLCBlbnRpdHkgPSBcInF1b3RlXCIsIHBlcnNpc3QgPSBcInNlc3Npb25cIiwgdHRsTXMgPSBudWxsLCBsZWdhY3lFbnRpdHkgPSBudWxsIH0gPSB7fSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVzZShzY29wZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSAodHlwZW9mIHNjb3BlS2V5ID09PSAnc3RyaW5nJykgPyBoYXNoU2NvcGUoc2NvcGVLZXkpIDogTnVtYmVyKHNjb3BlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoa2V5KSB8fCBrZXkgPD0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNjb3BlS2V5Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gREMuY3JlYXRlRGF0YUNvbnRleHQoeyBucywgc2NvcGVLZXk6IGtleSwgcGVyc2lzdCwgdHRsTXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE91ciBzaGltIHJldHVybnMgYSBoZWFkZXItb25seSByZXBvOyBpZiBQbGV4IERDIGlzIHByZXNlbnQsIGl0IHJldHVybnMgYSBwcm9wZXIgcmVwb1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBvID0gY3R4Lm1ha2VSZXBvKGZ1bmN0aW9uIEZsYXRSZXBvKCkgeyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY3R4LCByZXBvIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVzZSwgRmxhdFJlcG86IGZ1bmN0aW9uIEZsYXRSZXBvKCkgeyB9LCBvcHRzOiB7IG5zLCBlbnRpdHksIHBlcnNpc3QsIHR0bE1zLCBsZWdhY3lFbnRpdHkgfSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoREMsICdtYWtlRmxhdFNjb3BlZFJlcG8nLCB7IHZhbHVlOiBtYWtlRmxhdFNjb3BlZFJlcG8sIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkgeyAgfSBjYXRjaCB7IH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cbiAgICAvLyBJbnN0YWxsIGltbWVkaWF0ZWx5OyBpZiBQbGV4IGxhdGVyIGF1Z21lbnRzIGx0LmNvcmUuZGF0YSwgb3VyIGZhY3RvcnkgYWxyZWFkeSBleGlzdHNcbiAgICBpbnN0YWxsKCk7XG5cblxuXG59KSgpO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7QUFTQSxHQUFDLFdBQVk7QUFDVDtBQUNBLFVBQU0sT0FBUSxPQUFPLGlCQUFpQixjQUFlLGVBQWU7QUFHcEUsYUFBUyxPQUFPLE1BQU8sT0FBTyxpQkFBaUIsY0FBYyxlQUFlLFFBQVM7QUFFakYsVUFBSTtBQUFFLFlBQUksT0FBTyxPQUFPLGVBQWUsSUFBSSxNQUFNLEtBQU0sUUFBTyxFQUFFLElBQUksR0FBRyxLQUFLLE1BQU0sTUFBTSxJQUFJO0FBQUEsTUFBRyxRQUFRO0FBQUEsTUFBRTtBQUV6RyxVQUFJO0FBQUUsWUFBSSxJQUFJLElBQUksTUFBTSxLQUFNLFFBQU8sRUFBRSxJQUFJLElBQUksR0FBRyxLQUFLLE1BQU0sTUFBTSxJQUFJO0FBQUEsTUFBRyxRQUFRO0FBQUEs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
