// ==UserScript==
// @name        QT10_DEV
// @namespace   https://github.com/AlphaGeek509/plex-tampermonkey-scripts
// @version     3.6.36
// @description DEV-only build; includes user-start gate
// @match       https://*.plex.com/*
// @match       https://*.on.plex.com/*
// @require  http://localhost:5000/lt-plex-auth.user.js
// @require  http://localhost:5000/lt-plex-tm-utils.user.js
// @require  http://localhost:5000/lt-data-core.user.js
// @require  http://localhost:5000/lt-core.user.js
// @grant       GM_registerMenuCommand
// @grant       GM_getValue
// @grant       GM_setValue
// @grant       GM_xmlHttpRequest
// @grant       unsafeWindow
// @connect     *.plex.com
// @run-at      document-idle
// @noframes
// ==/UserScript==

(() => {
  // src/quote-tracking/qt10-customerCatalogGet/qt10.index.js
  (function() {
    "use strict";
    const DEV = true ? true : !!(typeof globalThis !== "undefined" && globalThis.__TM_DEV__);
    const CFG = {
      NAME: "QT10",
      ROUTES: [/^\/SalesAndCRM\/QuoteWizard(?:\/|$)/i],
      // KO-bound anchor we wait for to ensure VM is ready
      ANCHOR: '[data-val-property-name="CustomerNo"]',
      // Data sources
      DS_CATALOG_BY_CUSTOMER: 319,
      DS_CATALOG_CODE_BY_KEY: 22696,
      // If true, don’t pre-fire on page load; wait for a real user edit
      GATE_USER_EDIT: true,
      // Toast happy path
      TOAST_SUCCESS: true
    };
    const IS_TEST_ENV = /test\.on\.plex\.com$/i.test(location.hostname);
    try {
      TMUtils.setDebug?.(IS_TEST_ENV);
    } catch {
    }
    const L = TMUtils.getLogger?.(CFG.NAME);
    const dlog = (...a) => {
      if (IS_TEST_ENV) L?.log?.(...a);
    };
    const derror = (...a) => {
      if (IS_TEST_ENV) L?.error?.(...a);
    };
    if (!CFG.ROUTES.some((rx) => rx.test(location.pathname))) return;
    function getTabScopeId(ns = "QT") {
      try {
        const k = `lt:${ns}:scopeId`;
        let v = sessionStorage.getItem(k);
        if (!v) {
          v = String(Math.floor(Math.random() * 2147483647));
          sessionStorage.setItem(k, v);
        }
        return Number(v);
      } catch {
        return Math.floor(Math.random() * 2147483647);
      }
    }
    const SCOPE_DRAFT = "draft";
    let QT = null;
    async function waitForDC(timeoutMs = 2e4) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        const LT = typeof unsafeWindow !== "undefined" ? unsafeWindow.lt : window.lt;
        if (LT?.core?.data?.createDataContext) {
          if (LT.core.data.makeFlatScopedRepo) return LT.core.data;
        }
        await (TMUtils.sleep?.(50) || new Promise((r) => setTimeout(r, 50)));
      }
      throw new Error("DataCore not ready");
    }
    async function getQT() {
      if (QT) return QT;
      const DC = await waitForDC();
      if (!DC.makeFlatScopedRepo) {
        await (TMUtils.sleep?.(50) || new Promise((r) => setTimeout(r, 50)));
      }
      QT = DC.makeFlatScopedRepo({ ns: "QT", entity: "quote", legacyEntity: "QuoteHeader" });
      return QT;
    }
    let repoDraft = null;
    async function ensureDraftRepo() {
      try {
        if (repoDraft) return repoDraft;
        const DC = typeof unsafeWindow !== "undefined" ? unsafeWindow.lt?.core?.data : window.lt?.core?.data;
        if (!DC?.makeFlatScopedRepo) return null;
        const { use } = DC.makeFlatScopedRepo({ ns: "QT", entity: "quote", legacyEntity: "QuoteHeader" });
        const { repo } = use(getTabScopeId("QT"));
        repoDraft = repo;
        await repoDraft.ensureFromLegacyIfMissing?.();
        return repoDraft;
      } catch (e) {
        console.debug("QT10: repo not available yet; skipping persistence this cycle", e);
        return null;
      }
    }
    async function withFreshAuth(run) {
      try {
        return await run();
      } catch (err) {
        const status = err?.status || (/\b(\d{3})\b/.exec(err?.message || "") || [])[1];
        if (+status === 419) {
          await lt.core.auth.getKey();
          return await run();
        }
        throw err;
      }
    }
    async function ensureAuthOrToast() {
      try {
        if (await lt.core.auth.getKey()) return true;
      } catch {
      }
      TMUtils.toast?.("Sign-in required. Please log in, then retry.", "warn");
      return false;
    }
    async function anchorAppears(sel, { timeoutMs = 1e4, pollMs = 150 } = {}) {
      const t0 = Date.now();
      while (Date.now() - t0 < timeoutMs) {
        if (document.querySelector(sel)) return true;
        await (TMUtils.sleep?.(pollMs) || new Promise((r) => setTimeout(r, pollMs)));
      }
      return !!document.querySelector(sel);
    }
    let booted = false, booting = false, disposeWatcher = null, unsubscribeUrl = null;
    async function maybeBoot() {
      if (booted || booting) return;
      booting = true;
      try {
        if (!CFG.ROUTES.some((rx) => rx.test(location.pathname))) return;
        if (!await anchorAppears(CFG.ANCHOR)) return;
        if (!await ensureAuthOrToast()) return;
        const { viewModel } = await TMUtils.waitForModelAsync(CFG.ANCHOR, {
          pollMs: 200,
          timeoutMs: 8e3,
          logger: IS_TEST_ENV ? L : null
        });
        if (!viewModel) return;
        let lastCustomerNo = null;
        disposeWatcher = TMUtils.watchBySelector({
          selector: CFG.ANCHOR,
          // If user-gated, don’t fire an initial read; wait for real input
          initial: !CFG.GATE_USER_EDIT ? true : false,
          fireOn: "blur",
          settleMs: 350,
          logger: IS_TEST_ENV ? L : null,
          onChange: async () => {
            const customerNo = TMUtils.getObsValue(viewModel, "CustomerNo", { first: true, trim: true });
            if (!customerNo || customerNo === lastCustomerNo) return;
            lastCustomerNo = customerNo;
            await applyCatalogFor(customerNo, viewModel);
          }
        });
        booted = true;
      } catch (e) {
        booted = false;
        derror(`${CFG.NAME} init failed:`, e);
      } finally {
        booting = false;
      }
    }
    async function applyCatalogFor(customerNo, vm) {
      if (!customerNo) return;
      try {
        const rows1 = await withFreshAuth(
          () => lt.core.plex.dsRows(CFG.DS_CATALOG_BY_CUSTOMER, { Customer_No: customerNo })
        );
        const row1 = Array.isArray(rows1) ? rows1[0] : null;
        const catalogKey = row1?.Catalog_Key || 0;
        if (!catalogKey) {
          TMUtils.toast?.(`\u26A0\uFE0F No catalog for ${customerNo}`, "warn");
          return;
        }
        const rows2 = await withFreshAuth(
          () => lt.core.plex.dsRows(CFG.DS_CATALOG_CODE_BY_KEY, { Catalog_Key: catalogKey })
        );
        const catalogCode = (Array.isArray(rows2) ? rows2.map((r) => r?.Catalog_Code).find(Boolean) : null) || "";
        TMUtils.setObsValue(vm, "CatalogKey", catalogKey);
        TMUtils.setObsValue(vm, "CatalogCode", catalogCode);
        const repo = await ensureDraftRepo();
        if (repo) {
          persistDraftHeaderWithRetry({
            Customer_No: String(customerNo),
            Catalog_Key: Number(catalogKey),
            Catalog_Code: String(catalogCode || ""),
            Catalog_Fetched_At: Date.now()
          });
        }
        if (CFG.TOAST_SUCCESS) {
          TMUtils.toast?.(
            `\u2705 Customer: ${customerNo}
CatalogKey: ${catalogKey}
CatalogCode: ${catalogCode}`,
            "success"
          );
        }
      } catch (err) {
        TMUtils.toast?.(`\u274C Lookup failed: ${err?.message || err}`, "error");
        derror(err);
      }
    }
    const __QT10_PERSIST = { queue: null, timer: null };
    async function persistDraftHeaderWithRetry(patch, maxTries = 120, intervalMs = 250) {
      try {
        const repo = await ensureDraftRepo();
        if (repo) {
          await repo.patchHeader(patch);
          return true;
        }
      } catch (e) {
        console.debug("QT10: repo not ready now, will retry", e);
      }
      __QT10_PERSIST.queue = { ...__QT10_PERSIST.queue || {}, ...patch };
      if (__QT10_PERSIST.timer) return false;
      let triesLeft = maxTries;
      __QT10_PERSIST.timer = setInterval(async () => {
        try {
          const repoLater = await ensureDraftRepo();
          if (!repoLater) {
            if (--triesLeft <= 0) {
              clearInterval(__QT10_PERSIST.timer);
              __QT10_PERSIST.timer = null;
              console.debug("QT10: gave up persisting draft after retries");
            }
            return;
          }
          const payload = __QT10_PERSIST.queue;
          __QT10_PERSIST.queue = null;
          clearInterval(__QT10_PERSIST.timer);
          __QT10_PERSIST.timer = null;
          await repoLater.patchHeader(payload);
          console.debug("QT10: draft persisted after retry", payload);
        } catch (err) {
          console.warn("QT10: retry persist error", err);
        }
      }, intervalMs);
      return false;
    }
    unsubscribeUrl = TMUtils.onUrlChange?.(() => {
      if (!CFG.ROUTES.some((rx) => rx.test(location.pathname))) {
        try {
          disposeWatcher?.();
        } catch {
        }
        disposeWatcher = null;
        booted = false;
        booting = false;
        return;
      }
      setTimeout(maybeBoot, 0);
    });
    setTimeout(maybeBoot, 0);
    window.QT10_debugDraft = async () => {
      const repo = await ensureDraftRepo();
      console.debug("QT10 draft \u2192", await repo?.get());
    };
  })();
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vdG0tc2NyaXB0cy9zcmMvcXVvdGUtdHJhY2tpbmcvcXQxMC1jdXN0b21lckNhdGFsb2dHZXQvcXQxMC5pbmRleC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gc3JjL3F1b3RlLXRyYWNraW5nL3F0MTAtY3VzdG9tZXJDYXRhbG9nR2V0L3F0MTAuaW5kZXguanNcbi8vIERyb3AtaW4gbW9kdWxlIChidW5kbGVkIGJ5IGJ1aWxkLXBsdXMvZXNidWlsZCkuIE5vIFRNIGhlYWRlciBoZXJlOyB5b3VyIGJ1aWxkIGluamVjdHMgaXQuXG4vLyBSZXN0b3JlcyBidXNpbmVzcyBsb2dpYyBmcm9tIHF0MTAuYmFja3VwLmpzIGFuZCBmaXhlcyBSZXBvQmFzZSBjbGFzcyBpbnZvY2F0aW9uLlxuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vID09PT09IERldiBmbGFnIChidWlsZC10aW1lIHdpdGggcnVudGltZSBmYWxsYmFjaykgPT09PT1cbiAgICBjb25zdCBERVYgPSAodHlwZW9mIF9fQlVJTERfREVWX18gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICA/IF9fQlVJTERfREVWX19cbiAgICAgICAgOiAhISh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5fX1RNX0RFVl9fKTtcblxuICAgIC8vID09PT09IENvbmZpZyA9PT09PVxuICAgIGNvbnN0IENGRyA9IHtcbiAgICAgICAgTkFNRTogJ1FUMTAnLFxuICAgICAgICBST1VURVM6IFsvXlxcL1NhbGVzQW5kQ1JNXFwvUXVvdGVXaXphcmQoPzpcXC98JCkvaV0sXG4gICAgICAgIC8vIEtPLWJvdW5kIGFuY2hvciB3ZSB3YWl0IGZvciB0byBlbnN1cmUgVk0gaXMgcmVhZHlcbiAgICAgICAgQU5DSE9SOiAnW2RhdGEtdmFsLXByb3BlcnR5LW5hbWU9XCJDdXN0b21lck5vXCJdJyxcbiAgICAgICAgLy8gRGF0YSBzb3VyY2VzXG4gICAgICAgIERTX0NBVEFMT0dfQllfQ1VTVE9NRVI6IDMxOSxcbiAgICAgICAgRFNfQ0FUQUxPR19DT0RFX0JZX0tFWTogMjI2OTYsXG4gICAgICAgIC8vIElmIHRydWUsIGRvblx1MjAxOXQgcHJlLWZpcmUgb24gcGFnZSBsb2FkOyB3YWl0IGZvciBhIHJlYWwgdXNlciBlZGl0XG4gICAgICAgIEdBVEVfVVNFUl9FRElUOiB0cnVlLFxuICAgICAgICAvLyBUb2FzdCBoYXBweSBwYXRoXG4gICAgICAgIFRPQVNUX1NVQ0NFU1M6IHRydWUsXG4gICAgfTtcblxuICAgIC8vID09PT09IERlYnVnIC8gTG9nZ2VyIC8gREVWIHRvYXN0ID09PT09XG4gICAgY29uc3QgSVNfVEVTVF9FTlYgPSAvdGVzdFxcLm9uXFwucGxleFxcLmNvbSQvaS50ZXN0KGxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICB0cnkgeyBUTVV0aWxzLnNldERlYnVnPy4oSVNfVEVTVF9FTlYpOyB9IGNhdGNoIHsgfVxuICAgIGNvbnN0IEwgPSBUTVV0aWxzLmdldExvZ2dlcj8uKENGRy5OQU1FKTtcbiAgICBjb25zdCBkbG9nID0gKC4uLmEpID0+IHsgaWYgKElTX1RFU1RfRU5WKSBMPy5sb2c/LiguLi5hKTsgfTtcbiAgICBjb25zdCBkZXJyb3IgPSAoLi4uYSkgPT4geyBpZiAoSVNfVEVTVF9FTlYpIEw/LmVycm9yPy4oLi4uYSk7IH07XG5cbiAgICAvLyA9PT09PSBSb3V0ZSBhbGxvd2xpc3QgPT09PT1cbiAgICAvLyBhdm9pZCBkZXBlbmRpbmcgb24gVE1VdGlscyB0aW1pbmc7IHVzZSByZWdleCBvbiBwYXRobmFtZVxuICAgIGlmICghQ0ZHLlJPVVRFUy5zb21lKHJ4ID0+IHJ4LnRlc3QobG9jYXRpb24ucGF0aG5hbWUpKSkgcmV0dXJuO1xuXG4gICAgLy8gPT09IEFkZCB0aGlzIGhlbHBlciBuZWFyIHRoZSB0b3AgKG9uY2UpID09PVxuICAgIGZ1bmN0aW9uIGdldFRhYlNjb3BlSWQobnMgPSAnUVQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBrID0gYGx0OiR7bnN9OnNjb3BlSWRgO1xuICAgICAgICAgICAgbGV0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGspO1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgdiA9IFN0cmluZyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyXzE0N180ODNfNjQ3KSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShrLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgYmxvY2tlZFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDJfMTQ3XzQ4M182NDcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT0gRGF0YSB2aWEgbHQuY29yZS5kYXRhIChmbGF0IHtoZWFkZXIsIGxpbmVzfSkgPT09PT1cbiAgICBjb25zdCBTQ09QRV9EUkFGVCA9ICdkcmFmdCc7XG4gICAgbGV0IFFUID0gbnVsbDtcbiAgICBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yREModGltZW91dE1zID0gMjAwMDApIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0IDwgdGltZW91dE1zKSB7XG4gICAgICAgICAgICBjb25zdCBMVCA9ICh0eXBlb2YgdW5zYWZlV2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVuc2FmZVdpbmRvdy5sdCA6IHdpbmRvdy5sdCk7XG4gICAgICAgICAgICBpZiAoTFQ/LmNvcmU/LmRhdGE/LmNyZWF0ZURhdGFDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgb3VyIGZhY3RvcnkgaXMgYWxyZWFkeSBpbnN0YWxsZWQsIHdlXHUyMDE5cmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChMVC5jb3JlLmRhdGEubWFrZUZsYXRTY29wZWRSZXBvKSByZXR1cm4gTFQuY29yZS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc21hbGwgc2xlZXBcbiAgICAgICAgICAgIGF3YWl0IChUTVV0aWxzLnNsZWVwPy4oNTApIHx8IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCA1MCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFDb3JlIG5vdCByZWFkeScpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRRVCgpIHtcbiAgICAgICAgaWYgKFFUKSByZXR1cm4gUVQ7XG4gICAgICAgIGNvbnN0IERDID0gYXdhaXQgd2FpdEZvckRDKCk7XG4gICAgICAgIC8vIGx0LWRhdGEtY29yZSB3aWxsIGluc3RhbGwgdGhlIGZhY3Rvcnkgc29vbiBhZnRlciBEQyBpcyByZWFkeTsgaWYgc3RpbGwgbWlzc2luZywgcmV0cnkgb25jZVxuICAgICAgICBpZiAoIURDLm1ha2VGbGF0U2NvcGVkUmVwbykge1xuICAgICAgICAgICAgYXdhaXQgKFRNVXRpbHMuc2xlZXA/Lig1MCkgfHwgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDUwKSkpO1xuICAgICAgICB9XG4gICAgICAgIFFUID0gREMubWFrZUZsYXRTY29wZWRSZXBvKHsgbnM6ICdRVCcsIGVudGl0eTogJ3F1b3RlJywgbGVnYWN5RW50aXR5OiAnUXVvdGVIZWFkZXInIH0pO1xuICAgICAgICByZXR1cm4gUVQ7XG4gICAgfVxuXG4gICAgbGV0IHJlcG9EcmFmdCA9IG51bGw7XG4gICAgYXN5bmMgZnVuY3Rpb24gZW5zdXJlRHJhZnRSZXBvKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJlcG9EcmFmdCkgcmV0dXJuIHJlcG9EcmFmdDtcblxuICAgICAgICAgICAgLy8gTm9uLWJsb2NraW5nIHBlZWsgXHUyMDE0IGRvIE5PVCB3YWl0IDIwcyBoZXJlXG4gICAgICAgICAgICBjb25zdCBEQyA9ICh0eXBlb2YgdW5zYWZlV2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVuc2FmZVdpbmRvdy5sdD8uY29yZT8uZGF0YSA6IHdpbmRvdy5sdD8uY29yZT8uZGF0YSk7XG4gICAgICAgICAgICBpZiAoIURDPy5tYWtlRmxhdFNjb3BlZFJlcG8pIHJldHVybiBudWxsOyAvLyBsZXQgdGhlIHJldHJ5IGxvb3AgaGFuZGxlIGxhdGVyXG5cbiAgICAgICAgICAgIGNvbnN0IHsgdXNlIH0gPSBEQy5tYWtlRmxhdFNjb3BlZFJlcG8oeyBuczogJ1FUJywgZW50aXR5OiAncXVvdGUnLCBsZWdhY3lFbnRpdHk6ICdRdW90ZUhlYWRlcicgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHJlcG8gfSA9IHVzZShnZXRUYWJTY29wZUlkKCdRVCcpKTsgLy8gPC0tIG51bWVyaWMsIHBlci10YWIgc2NvcGVcbiAgICAgICAgICAgIHJlcG9EcmFmdCA9IHJlcG87XG4gICAgICAgICAgICBhd2FpdCByZXBvRHJhZnQuZW5zdXJlRnJvbUxlZ2FjeUlmTWlzc2luZz8uKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVwb0RyYWZ0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdRVDEwOiByZXBvIG5vdCBhdmFpbGFibGUgeWV0OyBza2lwcGluZyBwZXJzaXN0ZW5jZSB0aGlzIGN5Y2xlJywgZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gPT09PT0gQXV0aCBoZWxwZXJzID09PT09XG4gICAgYXN5bmMgZnVuY3Rpb24gd2l0aEZyZXNoQXV0aChydW4pIHtcbiAgICAgICAgdHJ5IHsgcmV0dXJuIGF3YWl0IHJ1bigpOyB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycj8uc3RhdHVzIHx8ICgvXFxiKFxcZHszfSlcXGIvLmV4ZWMoZXJyPy5tZXNzYWdlIHx8ICcnKSB8fCBbXSlbMV07XG4gICAgICAgICAgICBpZiAoK3N0YXR1cyA9PT0gNDE5KSB7IGF3YWl0IGx0LmNvcmUuYXV0aC5nZXRLZXkoKTsgcmV0dXJuIGF3YWl0IHJ1bigpOyB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZW5zdXJlQXV0aE9yVG9hc3QoKSB7XG4gICAgICAgIHRyeSB7IGlmIChhd2FpdCBsdC5jb3JlLmF1dGguZ2V0S2V5KCkpIHJldHVybiB0cnVlOyB9IGNhdGNoIHsgfVxuICAgICAgICBUTVV0aWxzLnRvYXN0Py4oJ1NpZ24taW4gcmVxdWlyZWQuIFBsZWFzZSBsb2cgaW4sIHRoZW4gcmV0cnkuJywgJ3dhcm4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vID09PT09IERPTS9LTyByZWFkaW5lc3MgPT09PT1cbiAgICBhc3luYyBmdW5jdGlvbiBhbmNob3JBcHBlYXJzKHNlbCwgeyB0aW1lb3V0TXMgPSAxMDAwMCwgcG9sbE1zID0gMTUwIH0gPSB7fSkge1xuICAgICAgICBjb25zdCB0MCA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gdDAgPCB0aW1lb3V0TXMpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgKFRNVXRpbHMuc2xlZXA/Lihwb2xsTXMpIHx8IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCBwb2xsTXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWwpO1xuICAgIH1cblxuICAgIC8vID09PT09IEJvb3RzdHJhcCAoU1BBLXNhZmUpID09PT09XG4gICAgbGV0IGJvb3RlZCA9IGZhbHNlLCBib290aW5nID0gZmFsc2UsIGRpc3Bvc2VXYXRjaGVyID0gbnVsbCwgdW5zdWJzY3JpYmVVcmwgPSBudWxsO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gbWF5YmVCb290KCkge1xuICAgICAgICBpZiAoYm9vdGVkIHx8IGJvb3RpbmcpIHJldHVybjtcbiAgICAgICAgYm9vdGluZyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIUNGRy5ST1VURVMuc29tZShyeCA9PiByeC50ZXN0KGxvY2F0aW9uLnBhdGhuYW1lKSkpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IGFuY2hvckFwcGVhcnMoQ0ZHLkFOQ0hPUikpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIShhd2FpdCBlbnN1cmVBdXRoT3JUb2FzdCgpKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCB7IHZpZXdNb2RlbCB9ID0gYXdhaXQgVE1VdGlscy53YWl0Rm9yTW9kZWxBc3luYyhDRkcuQU5DSE9SLCB7XG4gICAgICAgICAgICAgICAgcG9sbE1zOiAyMDAsIHRpbWVvdXRNczogODAwMCwgbG9nZ2VyOiBJU19URVNUX0VOViA/IEwgOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghdmlld01vZGVsKSByZXR1cm47XG5cblxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBRVDEwIGlzIENBVEFMT0ctT05MWTsgZG8gTk9UIHN0b3JlIFF1b3RlX0tleS9RdW90ZV9ObyBoZXJlLlxuXG4gICAgICAgICAgICAvLyBXYXRjaCBDdXN0b21lck5vIFx1MjE5MiBsb29rIHVwIGNhdGFsb2cgXHUyMTkyIHdyaXRlIHRvIERSQUZUIHNjb3BlXG4gICAgICAgICAgICBsZXQgbGFzdEN1c3RvbWVyTm8gPSBudWxsO1xuICAgICAgICAgICAgZGlzcG9zZVdhdGNoZXIgPSBUTVV0aWxzLndhdGNoQnlTZWxlY3Rvcih7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IENGRy5BTkNIT1IsXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNlci1nYXRlZCwgZG9uXHUyMDE5dCBmaXJlIGFuIGluaXRpYWwgcmVhZDsgd2FpdCBmb3IgcmVhbCBpbnB1dFxuICAgICAgICAgICAgICAgIGluaXRpYWw6ICFDRkcuR0FURV9VU0VSX0VESVQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZmlyZU9uOiAnYmx1cicsXG4gICAgICAgICAgICAgICAgc2V0dGxlTXM6IDM1MCxcbiAgICAgICAgICAgICAgICBsb2dnZXI6IElTX1RFU1RfRU5WID8gTCA6IG51bGwsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tZXJObyA9IFRNVXRpbHMuZ2V0T2JzVmFsdWUodmlld01vZGVsLCAnQ3VzdG9tZXJObycsIHsgZmlyc3Q6IHRydWUsIHRyaW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VzdG9tZXJObyB8fCBjdXN0b21lck5vID09PSBsYXN0Q3VzdG9tZXJObykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q3VzdG9tZXJObyA9IGN1c3RvbWVyTm87XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXBwbHlDYXRhbG9nRm9yKGN1c3RvbWVyTm8sIHZpZXdNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJvb3RlZCA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGJvb3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGVycm9yKGAke0NGRy5OQU1FfSBpbml0IGZhaWxlZDpgLCBlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGJvb3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09IENvcmUgYnVzaW5lc3MgbG9naWM6IEN1c3RvbWVyIFx1MjE5MiBDYXRhbG9nS2V5IFx1MjE5MiBDYXRhbG9nQ29kZSA9PT09PVxuICAgIGFzeW5jIGZ1bmN0aW9uIGFwcGx5Q2F0YWxvZ0ZvcihjdXN0b21lck5vLCB2bSkge1xuICAgICAgICBpZiAoIWN1c3RvbWVyTm8pIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEpIEN1c3RvbWVyIFx1MjE5MiBDYXRhbG9nS2V5XG4gICAgICAgICAgICBjb25zdCByb3dzMSA9IGF3YWl0IHdpdGhGcmVzaEF1dGgoKCkgPT5cbiAgICAgICAgICAgICAgICBsdC5jb3JlLnBsZXguZHNSb3dzKENGRy5EU19DQVRBTE9HX0JZX0NVU1RPTUVSLCB7IEN1c3RvbWVyX05vOiBjdXN0b21lck5vIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgcm93MSA9IEFycmF5LmlzQXJyYXkocm93czEpID8gcm93czFbMF0gOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgY2F0YWxvZ0tleSA9IHJvdzE/LkNhdGFsb2dfS2V5IHx8IDA7XG4gICAgICAgICAgICBpZiAoIWNhdGFsb2dLZXkpIHsgVE1VdGlscy50b2FzdD8uKGBcdTI2QTBcdUZFMEYgTm8gY2F0YWxvZyBmb3IgJHtjdXN0b21lck5vfWAsICd3YXJuJyk7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAvLyAyKSBDYXRhbG9nS2V5IFx1MjE5MiBDYXRhbG9nQ29kZVxuICAgICAgICAgICAgY29uc3Qgcm93czIgPSBhd2FpdCB3aXRoRnJlc2hBdXRoKCgpID0+XG4gICAgICAgICAgICAgICAgbHQuY29yZS5wbGV4LmRzUm93cyhDRkcuRFNfQ0FUQUxPR19DT0RFX0JZX0tFWSwgeyBDYXRhbG9nX0tleTogY2F0YWxvZ0tleSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGNhdGFsb2dDb2RlID0gKEFycmF5LmlzQXJyYXkocm93czIpID8gcm93czIubWFwKHIgPT4gcj8uQ2F0YWxvZ19Db2RlKS5maW5kKEJvb2xlYW4pIDogbnVsbCkgfHwgJyc7XG5cbiAgICAgICAgICAgIC8vIDMpIFJlZmxlY3QgaW4gS09cbiAgICAgICAgICAgIFRNVXRpbHMuc2V0T2JzVmFsdWUodm0sICdDYXRhbG9nS2V5JywgY2F0YWxvZ0tleSk7XG4gICAgICAgICAgICBUTVV0aWxzLnNldE9ic1ZhbHVlKHZtLCAnQ2F0YWxvZ0NvZGUnLCBjYXRhbG9nQ29kZSk7XG5cbiAgICAgICAgICAgIC8vIDQpIFN0YXNoIGludG8gRFJBRlQgc2NvcGUgKHBlci10YWIpXG4gICAgICAgICAgICAvLyBhZnRlciB5b3UndmUgY29tcHV0ZWQgY2F0YWxvZ0tleSwgY2F0YWxvZ0NvZGUsIGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IHJlcG8gPSBhd2FpdCBlbnN1cmVEcmFmdFJlcG8oKTtcbiAgICAgICAgICAgIGlmIChyZXBvKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3IChub24tYmxvY2tpbmcsIGF1dG8tcmV0cmllcyB1bnRpbCBEQyBpcyByZWFkeSlcbiAgICAgICAgICAgICAgICBwZXJzaXN0RHJhZnRIZWFkZXJXaXRoUmV0cnkoe1xuICAgICAgICAgICAgICAgICAgICBDdXN0b21lcl9ObzogU3RyaW5nKGN1c3RvbWVyTm8pLFxuICAgICAgICAgICAgICAgICAgICBDYXRhbG9nX0tleTogTnVtYmVyKGNhdGFsb2dLZXkpLFxuICAgICAgICAgICAgICAgICAgICBDYXRhbG9nX0NvZGU6IFN0cmluZyhjYXRhbG9nQ29kZSB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgIENhdGFsb2dfRmV0Y2hlZF9BdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQ0ZHLlRPQVNUX1NVQ0NFU1MpIHtcbiAgICAgICAgICAgICAgICBUTVV0aWxzLnRvYXN0Py4oXG4gICAgICAgICAgICAgICAgICAgIGBcdTI3MDUgQ3VzdG9tZXI6ICR7Y3VzdG9tZXJOb31cXG5DYXRhbG9nS2V5OiAke2NhdGFsb2dLZXl9XFxuQ2F0YWxvZ0NvZGU6ICR7Y2F0YWxvZ0NvZGV9YCxcbiAgICAgICAgICAgICAgICAgICAgJ3N1Y2Nlc3MnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBUTVV0aWxzLnRvYXN0Py4oYFx1Mjc0QyBMb29rdXAgZmFpbGVkOiAke2Vycj8ubWVzc2FnZSB8fCBlcnJ9YCwgJ2Vycm9yJyk7XG4gICAgICAgICAgICBkZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0gQmVzdC1lZmZvcnQgcGVyc2lzdGVuY2Ugd2l0aCByZXRyeSAoZHJhZnQgaGVhZGVyKSAtLS0tXG4gICAgY29uc3QgX19RVDEwX1BFUlNJU1QgPSB7IHF1ZXVlOiBudWxsLCB0aW1lcjogbnVsbCB9O1xuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcnNpc3REcmFmdEhlYWRlcldpdGhSZXRyeShwYXRjaCwgbWF4VHJpZXMgPSAxMjAsIGludGVydmFsTXMgPSAyNTApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG8gPSBhd2FpdCBlbnN1cmVEcmFmdFJlcG8oKTsgLy8gYmVzdC1lZmZvcnQsIG1heSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgaWYgKHJlcG8pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXBvLnBhdGNoSGVhZGVyKHBhdGNoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUVQxMDogcmVwbyBub3QgcmVhZHkgbm93LCB3aWxsIHJldHJ5JywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWZmZXIgcGF0Y2ggYW5kIHNjaGVkdWxlIHJldHJpZXNcbiAgICAgICAgX19RVDEwX1BFUlNJU1QucXVldWUgPSB7IC4uLihfX1FUMTBfUEVSU0lTVC5xdWV1ZSB8fCB7fSksIC4uLnBhdGNoIH07XG4gICAgICAgIGlmIChfX1FUMTBfUEVSU0lTVC50aW1lcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGxldCB0cmllc0xlZnQgPSBtYXhUcmllcztcbiAgICAgICAgX19RVDEwX1BFUlNJU1QudGltZXIgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9MYXRlciA9IGF3YWl0IGVuc3VyZURyYWZ0UmVwbygpO1xuICAgICAgICAgICAgICAgIGlmICghcmVwb0xhdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLXRyaWVzTGVmdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKF9fUVQxMF9QRVJTSVNULnRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fUVQxMF9QRVJTSVNULnRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1FUMTA6IGdhdmUgdXAgcGVyc2lzdGluZyBkcmFmdCBhZnRlciByZXRyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gX19RVDEwX1BFUlNJU1QucXVldWU7XG4gICAgICAgICAgICAgICAgX19RVDEwX1BFUlNJU1QucXVldWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX19RVDEwX1BFUlNJU1QudGltZXIpO1xuICAgICAgICAgICAgICAgIF9fUVQxMF9QRVJTSVNULnRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXBvTGF0ZXIucGF0Y2hIZWFkZXIocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUVQxMDogZHJhZnQgcGVyc2lzdGVkIGFmdGVyIHJldHJ5JywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1FUMTA6IHJldHJ5IHBlcnNpc3QgZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpbnRlcnZhbE1zKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvLyA9PT09PSBTUEEgbmF2IGhhbmRsaW5nID09PT09XG4gICAgdW5zdWJzY3JpYmVVcmwgPSBUTVV0aWxzLm9uVXJsQ2hhbmdlPy4oKCkgPT4ge1xuICAgICAgICBpZiAoIUNGRy5ST1VURVMuc29tZShyeCA9PiByeC50ZXN0KGxvY2F0aW9uLnBhdGhuYW1lKSkpIHtcbiAgICAgICAgICAgIHRyeSB7IGRpc3Bvc2VXYXRjaGVyPy4oKTsgfSBjYXRjaCB7IH1cbiAgICAgICAgICAgIGRpc3Bvc2VXYXRjaGVyID0gbnVsbDsgYm9vdGVkID0gZmFsc2U7IGJvb3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KG1heWJlQm9vdCwgMCk7XG4gICAgfSk7XG5cbiAgICBzZXRUaW1lb3V0KG1heWJlQm9vdCwgMCk7XG5cbiAgICAvLyBPcHRpb25hbCB0aW55IGRlYnVnXG4gICAgd2luZG93LlFUMTBfZGVidWdEcmFmdCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVwbyA9IGF3YWl0IGVuc3VyZURyYWZ0UmVwbygpO1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdRVDEwIGRyYWZ0IFx1MjE5MicsIGF3YWl0IHJlcG8/LmdldCgpKTtcbiAgICB9O1xufSkoKTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUEsR0FBQyxXQUFZO0FBQ1Q7QUFHQSxVQUFNLE1BQU8sT0FDUCxPQUNBLENBQUMs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STtBQUNBLGNBQU0sT0FBTyxNQUFNLGdCQUFnQjtBQUNuQyxZQUFJLE1BQU07QUFDTixnQkFBTSxLQUFLLFlBQVksS0FBSztBQUM1QixpQkFBTztBQUFBLFFBQ1g7QUFBQSxNQUNKLFNBQVMsR0FBRztBQUNSLGdCQUFRLE1BQU0sd0NBQXdDLENBQUM7QUFBQSxNQUMzRDtBQUdBLHFCQUFlLFFBQVEsRUFBRSxHQUFJLGVBQWUsU0FBUyxDQUFDLEdBQUksR0FBRyxNQUFNO0FBQ25FLFVBQUksZUFBZSxNQUFPLFFBQU87QUFFakMsVUFBSSxZQUFZO0FBQ2hCLHFCQUFlLFFBQVEsWUFBWSxZQUFZO0FBQzNDLFlBQUk7QUFDQSxnQkFBTSxZQUFZLE1BQU0sZ0JBQWdCO0FBQ3hDLGNBQUksQ0FBQyxXQUFXO0FBQ1osZ0JBQUksRUFBRSxhQUFhLEdBQUc7QUFDbEIsNEJBQWMsZUFBZSxLQUFLO0FBQ2xDLDZCQUFlLFFBQVE7QUFDdkIsc0JBQVEsTUFBTSw4Q0FBOEM7QUFBQSxZQUNoRTtBQUNBO0FBQUEsVUFDSjtBQUNBLGdCQUFNLFVBQVUsZUFBZTtBQUMvQix5QkFBZSxRQUFRO0FBQ3ZCLHdCQUFjLGVBQWUsS0FBSztBQUNsQyx5QkFBZSxRQUFRO0FBQ3ZCLGdCQUFNLFVBQVUsWUFBWSxPQUFPO0FBQ25DLGtCQUFRLE1BQU0scUNBQXFDLE9BQU87QUFBQSxRQUM5RCxTQUFTLEtBQUs7QUFDVixrQkFBUSxLQUFLLDZCQUE2QixHQUFHO0FBQUEsUUFDakQ7QUFBQSxNQUNKLEdBQUcsVUFBVTtBQUViLGFBQU87QUFBQSxJQUNYO0FBSUEscUJBQWlCLFFBQVEsY0FBYyxNQUFNO0FBQ3pDLFVBQUksQ0FBQyxJQUFJLE9BQU8sS0FBSyxRQUFNLEdBQUcsS0FBSyxTQUFTLFFBQVEsQ0FBQyxHQUFHO0FBQ3BELFlBQUk7QUFBRSwyQkFBaUI7QUFBQSxRQUFHLFFBQVE7QUFBQSxRQUFFO0FBQ3BDLHlCQUFpQjtBQUFNLGlCQUFTO0FBQU8sa0JBQVU7QUFDakQ7QUFBQSxNQUNKO0FBQ0EsaUJBQVcsV0FBVyxDQUFDO0FBQUEsSUFDM0IsQ0FBQztBQUVELGVBQVcsV0FBVyxDQUFDO0FBR3ZCLFdBQU8sa0JBQWtCLFlBQVk7QUFDakMsWUFBTSxPQUFPLE1BQU0sZ0JBQWdCO0FBQ25DLGNBQVEsTUFBTSxxQkFBZ0IsTUFBTSxNQUFNLElBQUksQ0FBQztBQUFBLElBQ25EO0FBQUEsRUFDSixHQUFHOyIsCiAgIm5hbWVzIjogW10KfQo=
