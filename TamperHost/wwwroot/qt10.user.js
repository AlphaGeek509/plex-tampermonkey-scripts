// ==UserScript==
// @name        QT10_DEV
// @namespace   https://github.com/AlphaGeek509/plex-tampermonkey-scripts
// @version     3.6.104
// @description DEV-only build; includes user-start gate
// @match       https://*.plex.com/*
// @match       https://*.on.plex.com/*
// @require      http://localhost:5000/lt-plex-tm-utils.user.js?v=3.6.104-1757720144265
// @require      http://localhost:5000/lt-plex-auth.user.js?v=3.6.104-1757720144265
// @require      http://localhost:5000/lt-ui-hub.js?v=3.6.104-1757720144265
// @require      http://localhost:5000/lt-core.user.js?v=3.6.104-1757720144265
// @require      http://localhost:5000/lt-data-core.user.js?v=3.6.104-1757720144265
// @resource     THEME_CSS http://localhost:5000/theme.css
// @grant       GM_registerMenuCommand
// @grant       GM_getValue
// @grant       GM_setValue
// @grant        GM_xmlhttpRequest
// @grant       unsafeWindow
// @connect     *.plex.com
// @run-at      document-idle
// @noframes
// @grant        GM_addStyle
// @grant        GM_getResourceText
// ==/UserScript==

(() => {
  // src/quote-tracking/qt10-customerCatalogGet/qt10.index.js
  (function() {
    "use strict";
    const DEV = true ? true : !!(typeof globalThis !== "undefined" && globalThis.__TM_DEV__);
    const CFG = {
      NAME: "QT10",
      ROUTES: [/^\/SalesAndCRM\/QuoteWizard(?:\/|$)/i],
      // KO-bound anchor we wait for to ensure VM is ready
      ANCHOR: '[data-val-property-name="CustomerNo"]',
      // Data sources
      DS_CATALOG_BY_CUSTOMER: 319,
      DS_CATALOG_CODE_BY_KEY: 22696,
      // If true, don’t pre-fire on page load; wait for a real user edit
      GATE_USER_EDIT: true,
      // Toast happy path
      TOAST_SUCCESS: true
    };
    const IS_TEST_ENV = /test\.on\.plex\.com$/i.test(location.hostname);
    try {
      TMUtils.setDebug?.(IS_TEST_ENV);
    } catch {
    }
    const L = TMUtils.getLogger?.(CFG.NAME);
    const dlog = (...a) => {
      if (IS_TEST_ENV) L?.log?.(...a);
    };
    const derror = (...a) => {
      if (IS_TEST_ENV) L?.error?.(...a);
    };
    if (!CFG.ROUTES.some((rx) => rx.test(location.pathname))) return;
    (() => {
      const hub = lt.core.hub;
      hub.setStatus("Ready", "info");
    })();
    function findDC(win = typeof unsafeWindow !== "undefined" ? unsafeWindow : window) {
      try {
        if (win.lt?.core?.data) return win.lt.core.data;
      } catch {
      }
      for (let i = 0; i < win.frames.length; i++) {
        try {
          const dc = findDC(win.frames[i]);
          if (dc) return dc;
        } catch {
        }
      }
      return null;
    }
    function getTabScopeId(ns = "QT") {
      try {
        const k = `lt:${ns}:scopeId`;
        let v = sessionStorage.getItem(k);
        if (!v) {
          v = String(Math.floor(Math.random() * 2147483647));
          sessionStorage.setItem(k, v);
        }
        return Number(v);
      } catch {
        return Math.floor(Math.random() * 2147483647);
      }
    }
    const SCOPE_DRAFT = "draft";
    let QT = null;
    async function waitForDC(timeoutMs = 2e4) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        const LT = typeof unsafeWindow !== "undefined" ? unsafeWindow.lt : window.lt;
        if (LT?.core?.data?.createDataContext) {
          if (LT.core.data.makeFlatScopedRepo) return LT.core.data;
        }
        await (TMUtils.sleep?.(50) || new Promise((r) => setTimeout(r, 50)));
      }
      throw new Error("DataCore not ready");
    }
    async function getQT() {
      if (QT) return QT;
      const DC = await waitForDC();
      if (!DC.makeFlatScopedRepo) {
        await (TMUtils.sleep?.(50) || new Promise((r) => setTimeout(r, 50)));
      }
      QT = DC.makeFlatScopedRepo({ ns: "QT", entity: "quote", legacyEntity: "QuoteHeader" });
      return QT;
    }
    let repoDraft = null;
    async function ensureDraftRepo() {
      try {
        if (repoDraft) return repoDraft;
        const DC = findDC();
        if (!DC?.makeFlatScopedRepo) return null;
        const { use } = DC.makeFlatScopedRepo({ ns: "QT", entity: "quote", legacyEntity: "QuoteHeader" });
        const { repo } = use(getTabScopeId("QT"));
        repoDraft = repo;
        await repoDraft.ensureFromLegacyIfMissing?.();
        return repoDraft;
      } catch (e) {
        console.debug("QT10: repo not available yet; skipping persistence this cycle", e);
        return null;
      }
    }
    async function withFreshAuth(run) {
      try {
        return await run();
      } catch (err) {
        const status = err?.status || (/\b(\d{3})\b/.exec(err?.message || "") || [])[1];
        if (+status === 419) {
          await lt.core.auth.getKey();
          return await run();
        }
        throw err;
      }
    }
    async function ensureAuthOrToast() {
      try {
        if (await lt.core.auth.getKey()) return true;
      } catch {
      }
      lt.core.hub.notify("warn", "Auth looks stale. Retrying\u2026", { toast: true });
      return false;
    }
    async function anchorAppears(sel, { timeoutMs = 1e4, pollMs = 150 } = {}) {
      const t0 = Date.now();
      while (Date.now() - t0 < timeoutMs) {
        if (document.querySelector(sel)) return true;
        await (TMUtils.sleep?.(pollMs) || new Promise((r) => setTimeout(r, pollMs)));
      }
      return !!document.querySelector(sel);
    }
    let booted = false, booting = false, disposeWatcher = null, unsubscribeUrl = null;
    async function maybeBoot() {
      if (booted || booting) return;
      booting = true;
      try {
        if (!CFG.ROUTES.some((rx) => rx.test(location.pathname))) return;
        if (!await anchorAppears(CFG.ANCHOR)) return;
        if (!await ensureAuthOrToast()) return;
        const { viewModel } = await TMUtils.waitForModelAsync(CFG.ANCHOR, {
          pollMs: 200,
          timeoutMs: 8e3,
          logger: IS_TEST_ENV ? L : null
        });
        if (!viewModel) return;
        let lastCustomerNo = null;
        disposeWatcher = TMUtils.watchBySelector({
          selector: CFG.ANCHOR,
          // If user-gated, don’t fire an initial read; wait for real input
          initial: !CFG.GATE_USER_EDIT ? true : false,
          fireOn: "blur",
          settleMs: 350,
          logger: IS_TEST_ENV ? L : null,
          onChange: async () => {
            const customerNo = TMUtils.getObsValue(viewModel, "CustomerNo", { first: true, trim: true });
            if (!customerNo || customerNo === lastCustomerNo) return;
            lastCustomerNo = customerNo;
            await applyCatalogFor(customerNo, viewModel);
          }
        });
        booted = true;
      } catch (e) {
        booted = false;
        derror(`${CFG.NAME} init failed:`, e);
      } finally {
        booting = false;
      }
    }
    async function applyCatalogFor(customerNo, vm) {
      if (!customerNo) return;
      lt.core.hub.setStatus("Linking catalog\u2026", "info", { sticky: true });
      const task = {
        success: (msg, t = 3e3) => {
          lt.core.hub.setStatus("", "info", { force: true });
          lt.core.hub.notify(msg, "success", { timeout: t });
        },
        error: (msg) => {
          lt.core.hub.setStatus("", "info", { force: true });
          lt.core.hub.notify(msg, "error", { timeout: 3500 });
        }
      };
      try {
        const rows1 = await withFreshAuth(
          () => lt.core.plex.dsRows(CFG.DS_CATALOG_BY_CUSTOMER, { Customer_No: customerNo })
        );
        const row1 = Array.isArray(rows1) ? rows1[0] : null;
        const catalogKey = row1?.Catalog_Key || 0;
        if (!catalogKey) {
          task.error("No catalog found for this customer.");
          return;
        }
        const rows2 = await withFreshAuth(
          () => lt.core.plex.dsRows(CFG.DS_CATALOG_CODE_BY_KEY, { Catalog_Key: catalogKey })
        );
        const catalogCode = (Array.isArray(rows2) ? rows2.map((r) => r?.Catalog_Code).find(Boolean) : null) || "";
        TMUtils.setObsValue(vm, "CatalogKey", catalogKey);
        TMUtils.setObsValue(vm, "CatalogCode", catalogCode);
        const repo = await ensureDraftRepo();
        if (repo) {
          persistDraftHeaderWithRetry({
            Customer_No: String(customerNo),
            Catalog_Key: Number(catalogKey),
            Catalog_Code: String(catalogCode || ""),
            Catalog_Fetched_At: Date.now(),
            Updated_At: Date.now()
          });
        }
        const codeTrimmed = typeof catalogCode === "string" ? catalogCode.trim() : "";
        const display = codeTrimmed || String(catalogKey ?? "");
        const msg = codeTrimmed ? `Linked: ${codeTrimmed} (key ${catalogKey})` : `Linked: key ${catalogKey}`;
        task.success(msg, 3e3);
      } catch (err) {
        task.error("No catalog found for this customer.");
        derror(err);
      }
    }
    const __QT10_PERSIST = { queue: null, timer: null };
    async function persistDraftHeaderWithRetry(patch, maxTries = 120, intervalMs = 250) {
      try {
        const repo = await ensureDraftRepo();
        if (repo) {
          await repo.patchHeader(patch);
          return true;
        }
      } catch (e) {
        console.debug("QT10: repo not ready now, will retry", e);
      }
      __QT10_PERSIST.queue = { ...__QT10_PERSIST.queue || {}, ...patch };
      if (__QT10_PERSIST.timer) return false;
      let triesLeft = maxTries;
      __QT10_PERSIST.timer = setInterval(async () => {
        try {
          const repoLater = await ensureDraftRepo();
          if (!repoLater) {
            if (--triesLeft <= 0) {
              clearInterval(__QT10_PERSIST.timer);
              __QT10_PERSIST.timer = null;
              console.debug("QT10: gave up persisting draft after retries");
            }
            return;
          }
          const payload = __QT10_PERSIST.queue;
          __QT10_PERSIST.queue = null;
          clearInterval(__QT10_PERSIST.timer);
          __QT10_PERSIST.timer = null;
          await repoLater.patchHeader(payload);
          console.debug("QT10: draft persisted after retry", payload);
        } catch (err) {
          console.warn("QT10: retry persist error", err);
        }
      }, intervalMs);
      return false;
    }
    unsubscribeUrl = TMUtils.onUrlChange?.(() => {
      if (!CFG.ROUTES.some((rx) => rx.test(location.pathname))) {
        try {
          disposeWatcher?.();
        } catch {
        }
        disposeWatcher = null;
        booted = false;
        booting = false;
        return;
      }
      setTimeout(maybeBoot, 0);
    });
    setTimeout(maybeBoot, 0);
    const W = typeof unsafeWindow !== "undefined" ? unsafeWindow : window;
    W.QT10_debugDraft = async () => {
      const repo = await ensureDraftRepo();
      const snap = await repo?.get();
      console.debug("QT10 draft \u2192", snap);
      return snap;
    };
    W.QT10_forceDraft = async (patch = {}) => {
      const repo = await ensureDraftRepo();
      if (!repo) {
        console.warn("QT10: repo not ready");
        return null;
      }
      await repo.patchHeader({
        Customer_No: "TEST",
        Catalog_Key: 99999,
        Catalog_Code: "TestCatalog",
        Updated_At: Date.now(),
        ...patch
      });
      return await repo.get();
    };
    W.QT10_checkDC = () => !!findDC()?.makeFlatScopedRepo;
    W.QT10_dcStatus = () => {
      const dc = findDC();
      return { hasCore: !!dc, hasFactory: !!dc?.makeFlatScopedRepo };
    };
  })();
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vdG0tc2NyaXB0cy9zcmMvcXVvdGUtdHJhY2tpbmcvcXQxMC1jdXN0b21lckNhdGFsb2dHZXQvcXQxMC5pbmRleC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gc3JjL3F1b3RlLXRyYWNraW5nL3F0MTAtY3VzdG9tZXJDYXRhbG9nR2V0L3F0MTAuaW5kZXguanNcbi8vIERyb3AtaW4gbW9kdWxlIChidW5kbGVkIGJ5IGJ1aWxkLXBsdXMvZXNidWlsZCkuIE5vIFRNIGhlYWRlciBoZXJlOyB5b3VyIGJ1aWxkIGluamVjdHMgaXQuXG4vLyBSZXN0b3JlcyBidXNpbmVzcyBsb2dpYyBmcm9tIHF0MTAuYmFja3VwLmpzIGFuZCBmaXhlcyBSZXBvQmFzZSBjbGFzcyBpbnZvY2F0aW9uLlxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gPT09PT0gRGV2IGZsYWcgKGJ1aWxkLXRpbWUgd2l0aCBydW50aW1lIGZhbGxiYWNrKSA9PT09PVxuICAgIGNvbnN0IERFViA9ICh0eXBlb2YgX19CVUlMRF9ERVZfXyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgID8gX19CVUlMRF9ERVZfX1xuICAgICAgICA6ICEhKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLl9fVE1fREVWX18pO1xuXG4gICAgLy8gPT09PT0gQ29uZmlnID09PT09XG4gICAgY29uc3QgQ0ZHID0ge1xuICAgICAgICBOQU1FOiAnUVQxMCcsXG4gICAgICAgIFJPVVRFUzogWy9eXFwvU2FsZXNBbmRDUk1cXC9RdW90ZVdpemFyZCg/OlxcL3wkKS9pXSxcbiAgICAgICAgLy8gS08tYm91bmQgYW5jaG9yIHdlIHdhaXQgZm9yIHRvIGVuc3VyZSBWTSBpcyByZWFkeVxuICAgICAgICBBTkNIT1I6ICdbZGF0YS12YWwtcHJvcGVydHktbmFtZT1cIkN1c3RvbWVyTm9cIl0nLFxuICAgICAgICAvLyBEYXRhIHNvdXJjZXNcbiAgICAgICAgRFNfQ0FUQUxPR19CWV9DVVNUT01FUjogMzE5LFxuICAgICAgICBEU19DQVRBTE9HX0NPREVfQllfS0VZOiAyMjY5NixcbiAgICAgICAgLy8gSWYgdHJ1ZSwgZG9uXHUyMDE5dCBwcmUtZmlyZSBvbiBwYWdlIGxvYWQ7IHdhaXQgZm9yIGEgcmVhbCB1c2VyIGVkaXRcbiAgICAgICAgR0FURV9VU0VSX0VESVQ6IHRydWUsXG4gICAgICAgIC8vIFRvYXN0IGhhcHB5IHBhdGhcbiAgICAgICAgVE9BU1RfU1VDQ0VTUzogdHJ1ZSxcbiAgICB9O1xuXG4gICAgLy8gPT09PT0gRGVidWcgLyBMb2dnZXIgLyBERVYgdG9hc3QgPT09PT1cbiAgICBjb25zdCBJU19URVNUX0VOViA9IC90ZXN0XFwub25cXC5wbGV4XFwuY29tJC9pLnRlc3QobG9jYXRpb24uaG9zdG5hbWUpO1xuICAgIHRyeSB7IFRNVXRpbHMuc2V0RGVidWc/LihJU19URVNUX0VOVik7IH0gY2F0Y2ggeyB9XG4gICAgY29uc3QgTCA9IFRNVXRpbHMuZ2V0TG9nZ2VyPy4oQ0ZHLk5BTUUpO1xuICAgIGNvbnN0IGRsb2cgPSAoLi4uYSkgPT4geyBpZiAoSVNfVEVTVF9FTlYpIEw/LmxvZz8uKC4uLmEpOyB9O1xuICAgIGNvbnN0IGRlcnJvciA9ICguLi5hKSA9PiB7IGlmIChJU19URVNUX0VOVikgTD8uZXJyb3I/LiguLi5hKTsgfTtcblxuICAgIC8vID09PT09IFJvdXRlIGFsbG93bGlzdCA9PT09PVxuICAgIC8vIGF2b2lkIGRlcGVuZGluZyBvbiBUTVV0aWxzIHRpbWluZzsgdXNlIHJlZ2V4IG9uIHBhdGhuYW1lXG4gICAgaWYgKCFDRkcuUk9VVEVTLnNvbWUocnggPT4gcngudGVzdChsb2NhdGlvbi5wYXRobmFtZSkpKSByZXR1cm47XG5cbiAgICAoKCkgPT4ge1xuICAgICAgICBjb25zdCBodWIgPSBsdC5jb3JlLmh1YjtcbiAgICAgICAgaHViLnNldFN0YXR1cyhcIlJlYWR5XCIsIFwiaW5mb1wiKTtcbiAgICB9KSgpO1xuXG5cblxuXG5cblxuICAgIC8vID09PSBBZGQgdGhpcyBoZWxwZXIgbmVhciB0aGUgdG9wIChvbmNlKSA9PT1cbiAgICAvLyBGaW5kIGx0LmNvcmUuZGF0YSBpbiBhbnkgc2FtZS1vcmlnaW4gZnJhbWVcbiAgICBmdW5jdGlvbiBmaW5kREMod2luID0gKHR5cGVvZiB1bnNhZmVXaW5kb3cgIT09ICd1bmRlZmluZWQnID8gdW5zYWZlV2luZG93IDogd2luZG93KSkge1xuICAgICAgICB0cnkgeyBpZiAod2luLmx0Py5jb3JlPy5kYXRhKSByZXR1cm4gd2luLmx0LmNvcmUuZGF0YTsgfSBjYXRjaCB7IH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW4uZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkgeyBjb25zdCBkYyA9IGZpbmREQyh3aW4uZnJhbWVzW2ldKTsgaWYgKGRjKSByZXR1cm4gZGM7IH0gY2F0Y2ggeyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRUYWJTY29wZUlkKG5zID0gJ1FUJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgayA9IGBsdDoke25zfTpzY29wZUlkYDtcbiAgICAgICAgICAgIGxldCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrKTtcbiAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgIHYgPSBTdHJpbmcoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMl8xNDdfNDgzXzY0NykpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oaywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHYpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGlmIHNlc3Npb25TdG9yYWdlIGlzIGJsb2NrZWRcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyXzE0N180ODNfNjQ3KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09IERhdGEgdmlhIGx0LmNvcmUuZGF0YSAoZmxhdCB7aGVhZGVyLCBsaW5lc30pID09PT09XG4gICAgY29uc3QgU0NPUEVfRFJBRlQgPSAnZHJhZnQnO1xuICAgIGxldCBRVCA9IG51bGw7XG4gICAgYXN5bmMgZnVuY3Rpb24gd2FpdEZvckRDKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydCA8IHRpbWVvdXRNcykge1xuICAgICAgICAgICAgY29uc3QgTFQgPSAodHlwZW9mIHVuc2FmZVdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1bnNhZmVXaW5kb3cubHQgOiB3aW5kb3cubHQpO1xuICAgICAgICAgICAgaWYgKExUPy5jb3JlPy5kYXRhPy5jcmVhdGVEYXRhQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIG91ciBmYWN0b3J5IGlzIGFscmVhZHkgaW5zdGFsbGVkLCB3ZVx1MjAxOXJlIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAoTFQuY29yZS5kYXRhLm1ha2VGbGF0U2NvcGVkUmVwbykgcmV0dXJuIExULmNvcmUuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNtYWxsIHNsZWVwXG4gICAgICAgICAgICBhd2FpdCAoVE1VdGlscy5zbGVlcD8uKDUwKSB8fCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgNTApKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhQ29yZSBub3QgcmVhZHknKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UVQoKSB7XG4gICAgICAgIGlmIChRVCkgcmV0dXJuIFFUO1xuICAgICAgICBjb25zdCBEQyA9IGF3YWl0IHdhaXRGb3JEQygpO1xuICAgICAgICAvLyBsdC1kYXRhLWNvcmUgd2lsbCBpbnN0YWxsIHRoZSBmYWN0b3J5IHNvb24gYWZ0ZXIgREMgaXMgcmVhZHk7IGlmIHN0aWxsIG1pc3NpbmcsIHJldHJ5IG9uY2VcbiAgICAgICAgaWYgKCFEQy5tYWtlRmxhdFNjb3BlZFJlcG8pIHtcbiAgICAgICAgICAgIGF3YWl0IChUTVV0aWxzLnNsZWVwPy4oNTApIHx8IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCA1MCkpKTtcbiAgICAgICAgfVxuICAgICAgICBRVCA9IERDLm1ha2VGbGF0U2NvcGVkUmVwbyh7IG5zOiAnUVQnLCBlbnRpdHk6ICdxdW90ZScsIGxlZ2FjeUVudGl0eTogJ1F1b3RlSGVhZGVyJyB9KTtcbiAgICAgICAgcmV0dXJuIFFUO1xuICAgIH1cblxuICAgIGxldCByZXBvRHJhZnQgPSBudWxsO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGVuc3VyZURyYWZ0UmVwbygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyZXBvRHJhZnQpIHJldHVybiByZXBvRHJhZnQ7XG5cbiAgICAgICAgICAgIC8vIE5vbi1ibG9ja2luZyBwZWVrIFx1MjAxNCBkbyBOT1Qgd2FpdCAyMHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgREMgPSBmaW5kREMoKTtcbiAgICAgICAgICAgIGlmICghREM/Lm1ha2VGbGF0U2NvcGVkUmVwbykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHVzZSB9ID0gREMubWFrZUZsYXRTY29wZWRSZXBvKHsgbnM6ICdRVCcsIGVudGl0eTogJ3F1b3RlJywgbGVnYWN5RW50aXR5OiAnUXVvdGVIZWFkZXInIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IHJlcG8gfSA9IHVzZShnZXRUYWJTY29wZUlkKCdRVCcpKTsgLy8gPC0tIG51bWVyaWMsIHBlci10YWIgc2NvcGVcbiAgICAgICAgICAgIHJlcG9EcmFmdCA9IHJlcG87XG4gICAgICAgICAgICBhd2FpdCByZXBvRHJhZnQuZW5zdXJlRnJvbUxlZ2FjeUlmTWlzc2luZz8uKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVwb0RyYWZ0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdRVDEwOiByZXBvIG5vdCBhdmFpbGFibGUgeWV0OyBza2lwcGluZyBwZXJzaXN0ZW5jZSB0aGlzIGN5Y2xlJywgZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gPT09PT0gQXV0aCBoZWxwZXJzID09PT09XG4gICAgYXN5bmMgZnVuY3Rpb24gd2l0aEZyZXNoQXV0aChydW4pIHtcbiAgICAgICAgdHJ5IHsgcmV0dXJuIGF3YWl0IHJ1bigpOyB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycj8uc3RhdHVzIHx8ICgvXFxiKFxcZHszfSlcXGIvLmV4ZWMoZXJyPy5tZXNzYWdlIHx8ICcnKSB8fCBbXSlbMV07XG4gICAgICAgICAgICBpZiAoK3N0YXR1cyA9PT0gNDE5KSB7IGF3YWl0IGx0LmNvcmUuYXV0aC5nZXRLZXkoKTsgcmV0dXJuIGF3YWl0IHJ1bigpOyB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZW5zdXJlQXV0aE9yVG9hc3QoKSB7XG4gICAgICAgIHRyeSB7IGlmIChhd2FpdCBsdC5jb3JlLmF1dGguZ2V0S2V5KCkpIHJldHVybiB0cnVlOyB9IGNhdGNoIHsgfVxuICAgICAgICBsdC5jb3JlLmh1Yi5ub3RpZnkoJ3dhcm4nLCAnQXV0aCBsb29rcyBzdGFsZS4gUmV0cnlpbmdcdTIwMjYnLCB7IHRvYXN0OiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gPT09PT0gRE9NL0tPIHJlYWRpbmVzcyA9PT09PVxuICAgIGFzeW5jIGZ1bmN0aW9uIGFuY2hvckFwcGVhcnMoc2VsLCB7IHRpbWVvdXRNcyA9IDEwMDAwLCBwb2xsTXMgPSAxNTAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHQwID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSB0MCA8IHRpbWVvdXRNcykge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBhd2FpdCAoVE1VdGlscy5zbGVlcD8uKHBvbGxNcykgfHwgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIHBvbGxNcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbCk7XG4gICAgfVxuXG4gICAgLy8gPT09PT0gQm9vdHN0cmFwIChTUEEtc2FmZSkgPT09PT1cbiAgICBsZXQgYm9vdGVkID0gZmFsc2UsIGJvb3RpbmcgPSBmYWxzZSwgZGlzcG9zZVdhdGNoZXIgPSBudWxsLCB1bnN1YnNjcmliZVVybCA9IG51bGw7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBtYXliZUJvb3QoKSB7XG4gICAgICAgIGlmIChib290ZWQgfHwgYm9vdGluZykgcmV0dXJuO1xuICAgICAgICBib290aW5nID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghQ0ZHLlJPVVRFUy5zb21lKHJ4ID0+IHJ4LnRlc3QobG9jYXRpb24ucGF0aG5hbWUpKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCEoYXdhaXQgYW5jaG9yQXBwZWFycyhDRkcuQU5DSE9SKSkpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IGVuc3VyZUF1dGhPclRvYXN0KCkpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdmlld01vZGVsIH0gPSBhd2FpdCBUTVV0aWxzLndhaXRGb3JNb2RlbEFzeW5jKENGRy5BTkNIT1IsIHtcbiAgICAgICAgICAgICAgICBwb2xsTXM6IDIwMCwgdGltZW91dE1zOiA4MDAwLCBsb2dnZXI6IElTX1RFU1RfRU5WID8gTCA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF2aWV3TW9kZWwpIHJldHVybjtcblxuXG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IFFUMTAgaXMgQ0FUQUxPRy1PTkxZOyBkbyBOT1Qgc3RvcmUgUXVvdGVfS2V5L1F1b3RlX05vIGhlcmUuXG5cbiAgICAgICAgICAgIC8vIFdhdGNoIEN1c3RvbWVyTm8gXHUyMTkyIGxvb2sgdXAgY2F0YWxvZyBcdTIxOTIgd3JpdGUgdG8gRFJBRlQgc2NvcGVcbiAgICAgICAgICAgIGxldCBsYXN0Q3VzdG9tZXJObyA9IG51bGw7XG4gICAgICAgICAgICBkaXNwb3NlV2F0Y2hlciA9IFRNVXRpbHMud2F0Y2hCeVNlbGVjdG9yKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogQ0ZHLkFOQ0hPUixcbiAgICAgICAgICAgICAgICAvLyBJZiB1c2VyLWdhdGVkLCBkb25cdTIwMTl0IGZpcmUgYW4gaW5pdGlhbCByZWFkOyB3YWl0IGZvciByZWFsIGlucHV0XG4gICAgICAgICAgICAgICAgaW5pdGlhbDogIUNGRy5HQVRFX1VTRVJfRURJVCA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaXJlT246ICdibHVyJyxcbiAgICAgICAgICAgICAgICBzZXR0bGVNczogMzUwLFxuICAgICAgICAgICAgICAgIGxvZ2dlcjogSVNfVEVTVF9FTlYgPyBMIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXN0b21lck5vID0gVE1VdGlscy5nZXRPYnNWYWx1ZSh2aWV3TW9kZWwsICdDdXN0b21lck5vJywgeyBmaXJzdDogdHJ1ZSwgdHJpbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b21lck5vIHx8IGN1c3RvbWVyTm8gPT09IGxhc3RDdXN0b21lck5vKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDdXN0b21lck5vID0gY3VzdG9tZXJObztcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhcHBseUNhdGFsb2dGb3IoY3VzdG9tZXJObywgdmlld01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYm9vdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYm9vdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkZXJyb3IoYCR7Q0ZHLk5BTUV9IGluaXQgZmFpbGVkOmAsIGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgYm9vdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT0gQ29yZSBidXNpbmVzcyBsb2dpYzogQ3VzdG9tZXIgXHUyMTkyIENhdGFsb2dLZXkgXHUyMTkyIENhdGFsb2dDb2RlID09PT09XG4gICAgYXN5bmMgZnVuY3Rpb24gYXBwbHlDYXRhbG9nRm9yKGN1c3RvbWVyTm8sIHZtKSB7XG4gICAgICAgIGlmICghY3VzdG9tZXJObykgcmV0dXJuO1xuXG4gICAgICAgIGx0LmNvcmUuaHViLnNldFN0YXR1cyhcIkxpbmtpbmcgY2F0YWxvZ1x1MjAyNlwiLCBcImluZm9cIiwgeyBzdGlja3k6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHRhc2sgPSB7XG4gICAgICAgICAgICBzdWNjZXNzOiAobXNnLCB0ID0gMzAwMCkgPT4geyBsdC5jb3JlLmh1Yi5zZXRTdGF0dXMoJycsICdpbmZvJywgeyBmb3JjZTogdHJ1ZSB9KTsgbHQuY29yZS5odWIubm90aWZ5KG1zZywgJ3N1Y2Nlc3MnLCB7IHRpbWVvdXQ6IHQgfSk7IH0sXG4gICAgICAgICAgICBlcnJvcjogKG1zZykgPT4geyBsdC5jb3JlLmh1Yi5zZXRTdGF0dXMoJycsICdpbmZvJywgeyBmb3JjZTogdHJ1ZSB9KTsgbHQuY29yZS5odWIubm90aWZ5KG1zZywgJ2Vycm9yJywgeyB0aW1lb3V0OiAzNTAwIH0pOyB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEpIEN1c3RvbWVyIFx1MjE5MiBDYXRhbG9nS2V5XG4gICAgICAgICAgICBjb25zdCByb3dzMSA9IGF3YWl0IHdpdGhGcmVzaEF1dGgoKCkgPT5cbiAgICAgICAgICAgICAgICBsdC5jb3JlLnBsZXguZHNSb3dzKENGRy5EU19DQVRBTE9HX0JZX0NVU1RPTUVSLCB7IEN1c3RvbWVyX05vOiBjdXN0b21lck5vIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgcm93MSA9IEFycmF5LmlzQXJyYXkocm93czEpID8gcm93czFbMF0gOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgY2F0YWxvZ0tleSA9IHJvdzE/LkNhdGFsb2dfS2V5IHx8IDA7XG4gICAgICAgICAgICBpZiAoIWNhdGFsb2dLZXkpIHsgdGFzay5lcnJvcignTm8gY2F0YWxvZyBmb3VuZCBmb3IgdGhpcyBjdXN0b21lci4nKTsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIC8vIDIpIENhdGFsb2dLZXkgXHUyMTkyIENhdGFsb2dDb2RlXG4gICAgICAgICAgICBjb25zdCByb3dzMiA9IGF3YWl0IHdpdGhGcmVzaEF1dGgoKCkgPT5cbiAgICAgICAgICAgICAgICBsdC5jb3JlLnBsZXguZHNSb3dzKENGRy5EU19DQVRBTE9HX0NPREVfQllfS0VZLCB7IENhdGFsb2dfS2V5OiBjYXRhbG9nS2V5IH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY2F0YWxvZ0NvZGUgPSAoQXJyYXkuaXNBcnJheShyb3dzMikgPyByb3dzMi5tYXAociA9PiByPy5DYXRhbG9nX0NvZGUpLmZpbmQoQm9vbGVhbikgOiBudWxsKSB8fCAnJztcblxuICAgICAgICAgICAgLy8gMykgUmVmbGVjdCBpbiBLT1xuICAgICAgICAgICAgVE1VdGlscy5zZXRPYnNWYWx1ZSh2bSwgJ0NhdGFsb2dLZXknLCBjYXRhbG9nS2V5KTtcbiAgICAgICAgICAgIFRNVXRpbHMuc2V0T2JzVmFsdWUodm0sICdDYXRhbG9nQ29kZScsIGNhdGFsb2dDb2RlKTtcblxuICAgICAgICAgICAgLy8gNCkgU3Rhc2ggaW50byBEUkFGVCBzY29wZSAocGVyLXRhYilcbiAgICAgICAgICAgIC8vIGFmdGVyIHlvdSd2ZSBjb21wdXRlZCBjYXRhbG9nS2V5LCBjYXRhbG9nQ29kZSwgZXRjLlxuICAgICAgICAgICAgY29uc3QgcmVwbyA9IGF3YWl0IGVuc3VyZURyYWZ0UmVwbygpO1xuICAgICAgICAgICAgaWYgKHJlcG8pIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgKG5vbi1ibG9ja2luZywgYXV0by1yZXRyaWVzIHVudGlsIERDIGlzIHJlYWR5KVxuICAgICAgICAgICAgICAgIHBlcnNpc3REcmFmdEhlYWRlcldpdGhSZXRyeSh7XG4gICAgICAgICAgICAgICAgICAgIEN1c3RvbWVyX05vOiBTdHJpbmcoY3VzdG9tZXJObyksXG4gICAgICAgICAgICAgICAgICAgIENhdGFsb2dfS2V5OiBOdW1iZXIoY2F0YWxvZ0tleSksXG4gICAgICAgICAgICAgICAgICAgIENhdGFsb2dfQ29kZTogU3RyaW5nKGNhdGFsb2dDb2RlIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgQ2F0YWxvZ19GZXRjaGVkX0F0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICBVcGRhdGVkX0F0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCdWlsZCBhIGNsZWFuIGRpc3BsYXkgdmFsdWUgdGhhdCBmYWxscyBiYWNrIGNvcnJlY3RseVxuICAgICAgICAgICAgY29uc3QgY29kZVRyaW1tZWQgPSAodHlwZW9mIGNhdGFsb2dDb2RlID09PSAnc3RyaW5nJykgPyBjYXRhbG9nQ29kZS50cmltKCkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXkgPSBjb2RlVHJpbW1lZCB8fCBTdHJpbmcoY2F0YWxvZ0tleSA/PyAnJyk7ICAvLyBmYWxsIGJhY2sgdG8ga2V5IGlmIGNvZGUgaXMgYmxhbmtcblxuICAgICAgICAgICAgLy8gSWYgeW91XHUyMDE5ZCBsaWtlIHRvIHNob3cgYm90aCB3aGVuIGF2YWlsYWJsZTpcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGNvZGVUcmltbWVkXG4gICAgICAgICAgICAgICAgPyBgTGlua2VkOiAke2NvZGVUcmltbWVkfSAoa2V5ICR7Y2F0YWxvZ0tleX0pYFxuICAgICAgICAgICAgICAgIDogYExpbmtlZDoga2V5ICR7Y2F0YWxvZ0tleX1gO1xuXG4gICAgICAgICAgICAvLyBGbGFzaCB0aGUgc3VjY2VzcyBmb3IgfjNzXG4gICAgICAgICAgICB0YXNrLnN1Y2Nlc3MobXNnLCAzMDAwKTtcblxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRhc2suZXJyb3IoJ05vIGNhdGFsb2cgZm91bmQgZm9yIHRoaXMgY3VzdG9tZXIuJyk7XG4gICAgICAgICAgICBkZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0gQmVzdC1lZmZvcnQgcGVyc2lzdGVuY2Ugd2l0aCByZXRyeSAoZHJhZnQgaGVhZGVyKSAtLS0tXG4gICAgY29uc3QgX19RVDEwX1BFUlNJU1QgPSB7IHF1ZXVlOiBudWxsLCB0aW1lcjogbnVsbCB9O1xuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcnNpc3REcmFmdEhlYWRlcldpdGhSZXRyeShwYXRjaCwgbWF4VHJpZXMgPSAxMjAsIGludGVydmFsTXMgPSAyNTApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG8gPSBhd2FpdCBlbnN1cmVEcmFmdFJlcG8oKTsgLy8gYmVzdC1lZmZvcnQsIG1heSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgaWYgKHJlcG8pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXBvLnBhdGNoSGVhZGVyKHBhdGNoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUVQxMDogcmVwbyBub3QgcmVhZHkgbm93LCB3aWxsIHJldHJ5JywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWZmZXIgcGF0Y2ggYW5kIHNjaGVkdWxlIHJldHJpZXNcbiAgICAgICAgX19RVDEwX1BFUlNJU1QucXVldWUgPSB7IC4uLihfX1FUMTBfUEVSU0lTVC5xdWV1ZSB8fCB7fSksIC4uLnBhdGNoIH07XG5cbiAgICAgICAgaWYgKF9fUVQxMF9QRVJTSVNULnRpbWVyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgbGV0IHRyaWVzTGVmdCA9IG1heFRyaWVzO1xuICAgICAgICBfX1FUMTBfUEVSU0lTVC50aW1lciA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwb0xhdGVyID0gYXdhaXQgZW5zdXJlRHJhZnRSZXBvKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBvTGF0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tdHJpZXNMZWZ0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX19RVDEwX1BFUlNJU1QudGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX19RVDEwX1BFUlNJU1QudGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUVQxMDogZ2F2ZSB1cCBwZXJzaXN0aW5nIGRyYWZ0IGFmdGVyIHJldHJpZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBfX1FUMTBfUEVSU0lTVC5xdWV1ZTtcbiAgICAgICAgICAgICAgICBfX1FUMTBfUEVSU0lTVC5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfX1FUMTBfUEVSU0lTVC50aW1lcik7XG4gICAgICAgICAgICAgICAgX19RVDEwX1BFUlNJU1QudGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlcG9MYXRlci5wYXRjaEhlYWRlcihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdRVDEwOiBkcmFmdCBwZXJzaXN0ZWQgYWZ0ZXIgcmV0cnknLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUVQxMDogcmV0cnkgcGVyc2lzdCBlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGludGVydmFsTXMpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIC8vID09PT09IFNQQSBuYXYgaGFuZGxpbmcgPT09PT1cbiAgICB1bnN1YnNjcmliZVVybCA9IFRNVXRpbHMub25VcmxDaGFuZ2U/LigoKSA9PiB7XG4gICAgICAgIGlmICghQ0ZHLlJPVVRFUy5zb21lKHJ4ID0+IHJ4LnRlc3QobG9jYXRpb24ucGF0aG5hbWUpKSkge1xuICAgICAgICAgICAgdHJ5IHsgZGlzcG9zZVdhdGNoZXI/LigpOyB9IGNhdGNoIHsgfVxuICAgICAgICAgICAgZGlzcG9zZVdhdGNoZXIgPSBudWxsOyBib290ZWQgPSBmYWxzZTsgYm9vdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQobWF5YmVCb290LCAwKTtcbiAgICB9KTtcblxuICAgIHNldFRpbWVvdXQobWF5YmVCb290LCAwKTtcblxuICAgIC8vIEV4cG9zZSBoZWxwZXJzIHRvIHRoZSBwYWdlIGNvbnRleHQgKHNvIERldlRvb2xzIGNvbnNvbGUgY2FuIGNhbGwgdGhlbSlcbiAgICBjb25zdCBXID0gKHR5cGVvZiB1bnNhZmVXaW5kb3cgIT09ICd1bmRlZmluZWQnID8gdW5zYWZlV2luZG93IDogd2luZG93KTtcblxuICAgIFcuUVQxMF9kZWJ1Z0RyYWZ0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXBvID0gYXdhaXQgZW5zdXJlRHJhZnRSZXBvKCk7XG4gICAgICAgIGNvbnN0IHNuYXAgPSBhd2FpdCByZXBvPy5nZXQoKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnUVQxMCBkcmFmdCBcdTIxOTInLCBzbmFwKTtcbiAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgfTtcblxuICAgIFcuUVQxMF9mb3JjZURyYWZ0ID0gYXN5bmMgKHBhdGNoID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgcmVwbyA9IGF3YWl0IGVuc3VyZURyYWZ0UmVwbygpO1xuICAgICAgICBpZiAoIXJlcG8pIHsgY29uc29sZS53YXJuKCdRVDEwOiByZXBvIG5vdCByZWFkeScpOyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBhd2FpdCByZXBvLnBhdGNoSGVhZGVyKHtcbiAgICAgICAgICAgIEN1c3RvbWVyX05vOiAnVEVTVCcsXG4gICAgICAgICAgICBDYXRhbG9nX0tleTogOTk5OTksXG4gICAgICAgICAgICBDYXRhbG9nX0NvZGU6ICdUZXN0Q2F0YWxvZycsXG4gICAgICAgICAgICBVcGRhdGVkX0F0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgLi4ucGF0Y2hcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXBvLmdldCgpO1xuICAgIH07XG5cbiAgICBXLlFUMTBfY2hlY2tEQyA9ICgpID0+ICEhKGZpbmREQygpPy5tYWtlRmxhdFNjb3BlZFJlcG8pO1xuICAgIFcuUVQxMF9kY1N0YXR1cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZGMgPSBmaW5kREMoKTtcbiAgICAgICAgcmV0dXJuIHsgaGFzQ29yZTogISFkYywgaGFzRmFjdG9yeTogISFkYz8ubWFrZUZsYXRTY29wZWRSZXBvIH07XG4gICAgfTtcbn0pKCk7Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUEsR0FBQyxXQUFZO0FBRVQ7QUFHQSxVQUFNLE1BQU8sT0FDUCxPQUNBLENBQUMsRUFBRSxPQUFPLGVBQWUsZUFBZSxXQUFXO0FBR3pELFVBQU0sTUFBTTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sUUFBUSxDQUFDLHNDQUFzQztBQUFBO0FBQUEsTUFFL0MsUUFBUTtBQUFBO0FBQUEsTUFFUix3QkFBd0I7QUFBQSxNQUN4Qix3QkFBd0I7QUFBQTtBQUFBLE1BRXhCLGdCQUFnQjtBQUFBO0FBQUEsTUFFaEIsZUFBZTtBQUFBLElBQ25CO0FBR0EsVUFBTSxjQUFjLHdCQUF3QixLQUFLLFNBQVMsUUFBUTtBQUNsRSxRQUFJO0FBQUUsY0FBUSxXQUFXLFdBQVc7QUFBQSxJQUFHLFFBQVE7QUFBQSxJQUFFO0FBQ2pELFVBQU0sSUFBSSxRQUFRLFlBQVksSUFBSSxJQUFJO0FBQ3RDLFVBQU0sT0FBTyxJQUFJLE1BQU07QUFBRSxVQUFJLFlBQWEsSUFBRyxNQUFNLEdBQUcsQ0FBQztBQUFBLElBQUc7QUFDMUQsVUFBTSxTQUFTLElBQUksTUFBTTtBQUFFLFVBQUksWUFBYSxJQUFHLFFBQVEsR0FBRyxDQUFDO0FBQUEsSUFBRztBQUk5RCxRQUFJLENBQUMsSUFBSSxPQUFPLEtBQUssUUFBTSxHQUFHLEtBQUssU0FBUyxRQUFRLENBQUMsRUFBRztBQUV4RCxLQUFDLE1BQU07QUFDSCxZQUFNLE1BQU0sR0FBRyxLQUFLO0FBQ3BCLFVBQUksVUFBVSxTQUFTLE1BQU07QUFBQSxJQUNqQyxHQUFHO0FBU0gsYUFBUyxPQUFPLE1BQU8sT0FBTyxpQkFBaUIsY0FBYyxlQUFlLFFBQVM7QUFDakYsVUFBSTtBQUFFLFlBQUksSUFBSSxJQUFJLE1BQU0sS0FBTSxRQUFPLElBQUksR0FBRyxLQUFLO0FBQUEsTUFBTSxRQUFRO0FBQUEsTUFBRTtBQUNqRSxlQUFTLElBQUksR0FBRyxJQUFJLElBQUksT0FBTyxRQUFRLEtBQUs7QUFDeEMsWUFBSTtBQUFFLGdCQUFNLEtBQUssT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDO0FBQUcsY0FBSSxHQUFJLFFBQU87QUFBQSxRQUFJLFFBQVE7QUFBQSxRQUFFO0FBQUEsTUFDekU7QUFDQSxhQUFPO0FBQUEsSUFDWDtBQUdBLGFBQVMsY0FBYyxLQUFLLE1BQU07QUFDOUIsVUFBSTtBQUNBLGNBQU0sSUFBSSxNQUFNLEVBQUU7QUFDbEIsWUFBSSxJQUFJLGVBQWUsUUFBUSxDQUFDO0FBQ2hDLFlBQUksQ0FBQyxHQUFHO0FBQ0osY0FBSSxPQUFPLEtBQUssTUFBTSxLQUFLLE9BQU8sSUFBSSxVQUFhLENBQUM7QUFDcEQseUJBQWUsUUFBUSxHQUFHLENBQUM7QUFBQSxRQUMvQjtBQUNBLGVBQU8sT0FBTyxDQUFDO0FBQUEsTUFDbkIsUUFBUTtBQUVKLGVBQU8sS0FBSyxNQUFNLEtBQUssT0FBTyxJQUFJLFVBQWE7QUFBQSxNQUNuRDtBQUFBLElBQ0o7QUFHQSxVQUFNLGNBQWM7QUFDcEIsUUFBSSxLQUFLO0FBQ1QsbUJBQWUsVUFBVSxZQUFZLEtBQU87QUFDeEMsWUFBTSxRQUFRLEtBQUssSUFBSTtBQUN2QixhQUFPLEtBQUssSUFBSSxJQUFJLFFBQVEsV0FBVztBQUNuQyxjQUFNLEtBQU0sT0FBTyxpQkFBaUIsY0FBYyxhQUFhLEtBQUssT0FBTztBQUMzRSxZQUFJLElBQUksTUFBTSxNQUFNLG1CQUFtQjtBQUVuQyxjQUFJLEdBQUcsS0FBSyxLQUFLLG1CQUFvQixRQUFPLEdBQUcsS0FBSztBQUFBLFFBQ3hEO0FBRUEsZUFBTyxRQUFRLFFBQVEsRUFBRSxLQUFLLElBQUksUUFBUSxPQUFLLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFBQSxNQUNwRTtBQUNBLFlBQU0sSUFBSSxNQUFNLG9CQUFvQjtBQUFBLElBQ3hDO0FBQ0EsbUJBQWUsUUFBUTtBQUNuQixVQUFJLEdBQUksUUFBTztBQUNmLFlBQU0sS0FBSyxNQUFNLFVBQVU7QUFFM0IsVUFBSSxDQUFDLEdBQUcsb0JBQW9CO0FBQ3hCLGVBQU8sUUFBUSxRQUFRLEVBQUUsS0FBSyxJQUFJLFFBQVEsT0FBSyxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQUEsTUFDcEU7QUFDQSxXQUFLLEdBQUcsbUJBQW1CLEVBQUUsSUFBSSxNQUFNLFFBQVEsU0FBUyxjQUFjLGNBQWMsQ0FBQztBQUNyRixhQUFPO0FBQUEsSUFDWDtBQUVBLFFBQUksWUFBWTtBQUNoQixtQkFBZSxrQkFBa0I7QUFDN0IsVUFBSTtBQUNBLFlBQUksVUFBVyxRQUFPO0FBR3RCLGNBQU0sS0FBSyxPQUFPO0FBQ2xCLFlBQUksQ0FBQyxJQUFJLG1CQUFvQixRQUFPO0FBQ3BDLGNBQU0sRUFBRSxJQUFJLElBQUksR0FBRyxtQkFBbUIsRUFBRSxJQUFJLE1BQU0sUUFBUSxTQUFTLGNBQWMsY0FBYyxDQUFDO0FBRWhHLGNBQU0sRUFBRSxLQUFLLElBQUksSUFBSSxjQUFjLElBQUksQ0FBQztBQUN4QyxvQkFBWTtBQUNaLGNBQU0sVUFBVSw0QkFBNEI7QUFDNUMsZUFBTztBQUFBLE1BQ1gsU0FBUyxHQUFHO0FBQ1IsZ0JBQVEsTUFBTSxpRUFBaUUsQ0FBQztBQUNoRixlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFJQSxtQkFBZSxjQUFjLEtBQUs7QUFDOUIsVUFBSTtBQUFFLGVBQU8sTUFBTSxJQUFJO0FBQUEsTUFBRyxTQUNuQixLQUFLO0FBQ1IsY0FBTSxTQUFTLEtBQUssV0FBVyxjQUFjLEtBQUssS0FBSyxXQUFXLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQztBQUM5RSxZQUFJLENBQUMsV0FBVyxLQUFLO0FBQUUsZ0JBQU0sR0FBRyxLQUFLLEtBQUssT0FBTztBQUFHLGlCQUFPLE1BQU0sSUFBSTtBQUFBLFFBQUc7QUFDeEUsY0FBTTtBQUFBLE1BQ1Y7QUFBQSxJQUNKO0FBQ0EsbUJBQWUsb0JBQW9CO0FBQy9CLFVBQUk7QUFBRSxZQUFJLE1BQU0sR0FBRyxLQUFLLEtBQUssT0FBTyxFQUFHLFFBQU87QUFBQSxNQUFNLFFBQVE7QUFBQSxNQUFFO0FBQzlELFNBQUcsS0FBSyxJQUFJLE9BQU8sUUFBUSxvQ0FBK0IsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUN6RSxhQUFPO0FBQUEsSUFDWDtBQUdBLG1CQUFlLGNBQWMsS0FBSyxFQUFFLFlBQVksS0FBTyxTQUFTLElBQUksSUFBSSxDQUFDLEdBQUc7QUFDeEUsWUFBTSxLQUFLLEtBQUssSUFBSTtBQUNwQixhQUFPLEtBQUssSUFBSSxJQUFJLEtBQUssV0FBVztBQUNoQyxZQUFJLFNBQVMsY0FBYyxHQUFHLEVBQUcsUUFBTztBQUN4QyxlQUFPLFFBQVEsUUFBUSxNQUFNLEtBQUssSUFBSSxRQUFRLE9BQUssV0FBVyxHQUFHLE1BQU0sQ0FBQztBQUFBLE1BQzVFO0FBQ0EsYUFBTyxDQUFDLENBQUMsU0FBUyxjQUFjLEdBQUc7QUFBQSxJQUN2QztBQUdBLFFBQUksU0FBUyxPQUFPLFVBQVUsT0FBTyxpQkFBaUIsTUFBTSxpQkFBaUI7QUFFN0UsbUJBQWUsWUFBWTtBQUN2QixVQUFJLFVBQVUsUUFBUztBQUN2QixnQkFBVTtBQUNWLFVBQUk7QUFDQSxZQUFJLENBQUMsSUFBSSxPQUFPLEtBQUssUUFBTSxHQUFHLEtBQUssU0FBUyxRQUFRLENBQUMsRUFBRztBQUN4RCxZQUFJLENBQUUsTUFBTSxjQUFjLElBQUksTUFBTSxFQUFJO0FBQ3hDLFlBQUksQ0FBRSxNQUFNLGtCQUFrQixFQUFJO0FBRWxDLGNBQU0sRUFBRSxVQUFVLElBQUksTUFBTSxRQUFRLGtCQUFrQixJQUFJLFFBQVE7QUFBQSxVQUM5RCxRQUFRO0FBQUEsVUFBSyxXQUFXO0FBQUEsVUFBTSxRQUFRLGNBQWMsSUFBSTtBQUFBLFFBQzVELENBQUM7QUFDRCxZQUFJLENBQUMsVUFBVztBQU1oQixZQUFJLGlCQUFpQjtBQUNyQix5QkFBaUIsUUFBUSxnQkFBZ0I7QUFBQSxVQUNyQyxVQUFVLElBQUk7QUFBQTtBQUFBLFVBRWQsU0FBUyxDQUFDLElBQUksaUJBQWlCLE9BQU87QUFBQSxVQUN0QyxRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixRQUFRLGNBQWMsSUFBSTtBQUFBLFVBQzFCLFVBQVUsWUFBWTtBQUNsQixrQkFBTSxhQUFhLFFBQVEsWUFBWSxXQUFXLGNBQWMsRUFBRSxPQUFPLE1BQU0sTUFBTSxLQUFLLENBQUM7QUFDM0YsZ0JBQUksQ0FBQyxjQUFjLGVBQWUsZUFBZ0I7QUFDbEQsNkJBQWlCO0FBRWpCLGtCQUFNLGdCQUFnQixZQUFZLFNBQVM7QUFBQSxVQUMvQztBQUFBLFFBQ0osQ0FBQztBQUVELGlCQUFTO0FBQUEsTUFDYixTQUFTLEdBQUc7QUFDUixpQkFBUztBQUNULGVBQU8sR0FBRyxJQUFJLElBQUksaUJBQWlCLENBQUM7QUFBQSxNQUN4QyxVQUFFO0FBQ0Usa0JBQVU7QUFBQSxNQUNkO0FBQUEsSUFDSjtBQUdBLG1CQUFlLGdCQUFnQixZQUFZLElBQUk7QUFDM0MsVUFBSSxDQUFDLFdBQVk7QUFFakIsU0FBRyxLQUFLLElBQUksVUFBVSx5QkFBb0IsUUFBUSxFQUFFLFFBQVEsS0FBSyxDQUFDO0FBQ2xFLFlBQU0sT0FBTztBQUFBLFFBQ1QsU0FBUyxDQUFDLEtBQUssSUFBSSxRQUFTO0FBQUUsYUFBRyxLQUFLLElBQUksVUFBVSxJQUFJLFFBQVEsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUFHLGFBQUcsS0FBSyxJQUFJLE9BQU8sS0FBSyxXQUFXLEVBQUUsU0FBUyxFQUFFLENBQUM7QUFBQSxRQUFHO0FBQUEsUUFDdEksT0FBTyxDQUFDLFFBQVE7QUFBRSxhQUFHLEtBQUssSUFBSSxVQUFVLElBQUksUUFBUSxFQUFFLE9BQU8sS0FBSyxDQUFDO0FBQUcsYUFBRyxLQUFLLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRSxTQUFTLEtBQUssQ0FBQztBQUFBLFFBQUc7QUFBQSxNQUMvSDtBQUVBLFVBQUk7QUFFQSxjQUFNLFFBQVEsTUFBTTtBQUFBLFVBQWMsTUFDOUIsR0FBRyxLQUFLLEtBQUssT0FBTyxJQUFJLHdCQUF3QixFQUFFLGFBQWEsV0FBVyxDQUFDO0FBQUEsUUFDL0U7QUFDQSxjQUFNLE9BQU8sTUFBTSxRQUFRLEtBQUssSUFBSSxNQUFNLENBQUMsSUFBSTtBQUMvQyxjQUFNLGFBQWEsTUFBTSxlQUFlO0FBQ3hDLFlBQUksQ0FBQyxZQUFZO0FBQUUsZUFBSyxNQUFNLHFDQUFxQztBQUFHO0FBQUEsUUFBUTtBQUc5RSxjQUFNLFFBQVEsTUFBTTtBQUFBLFVBQWMsTUFDOUIsR0FBRyxLQUFLLEtBQUssT0FBTyxJQUFJLHdCQUF3QixFQUFFLGFBQWEsV0FBVyxDQUFDO0FBQUEsUUFDL0U7QUFDQSxjQUFNLGVBQWUsTUFBTSxRQUFRLEtBQUssSUFBSSxNQUFNLElBQUksT0FBSyxHQUFHLFlBQVksRUFBRSxLQUFLLE9BQU8sSUFBSSxTQUFTO0FBR3JHLGdCQUFRLFlBQVksSUFBSSxjQUFjLFVBQVU7QUFDaEQsZ0JBQVEsWUFBWSxJQUFJLGVBQWUsV0FBVztBQUlsRCxjQUFNLE9BQU8sTUFBTSxnQkFBZ0I7QUFDbkMsWUFBSSxNQUFNO0FBRU4sc0NBQTRCO0FBQUEsWUFDeEIsYUFBYSxPQUFPLFVBQVU7QUFBQSxZQUM5QixhQUFhLE9BQU8sVUFBVTtBQUFBLFlBQzlCLGNBQWMsT0FBTyxlQUFlLEVBQUU7QUFBQSxZQUN0QyxvQkFBb0IsS0FBSyxJQUFJO0FBQUEsWUFDN0IsWUFBWSxLQUFLLElBQUk7QUFBQSxVQUN6QixDQUFDO0FBQUEsUUFDTDtBQUdBLGNBQU0sY0FBZSxPQUFPLGdCQUFnQixXQUFZLFlBQVksS0FBSyxJQUFJO0FBQzdFLGNBQU0sVUFBVSxlQUFlLE9BQU8sY0FBYyxFQUFFO0FBR3RELGNBQU0sTUFBTSxjQUNOLFdBQVcsV0FBVyxTQUFTLFVBQVUsTUFDekMsZUFBZSxVQUFVO0FBRy9CLGFBQUssUUFBUSxLQUFLLEdBQUk7QUFBQSxNQUUxQixTQUFTLEtBQUs7QUFDVixhQUFLLE1BQU0scUNBQXFDO0FBQ2hELGVBQU8sR0FBRztBQUFBLE1BQ2Q7QUFBQSxJQUNKO0FBR0EsVUFBTSxpQkFBaUIsRUFBRSxPQUFPLE1BQU0sT0FBTyxLQUFLO0FBQ2xELG1CQUFlLDRCQUE0QixPQUFPLFdBQVcsS0FBSyxhQUFhLEtBQUs7QUFDaEYsVUFBSTtBQUNBLGNBQU0sT0FBTyxNQUFNLGdCQUFnQjtBQUNuQyxZQUFJLE1BQU07QUFDTixnQkFBTSxLQUFLLFlBQVksS0FBSztBQUM1QixpQkFBTztBQUFBLFFBQ1g7QUFBQSxNQUNKLFNBQVMsR0FBRztBQUNSLGdCQUFRLE1BQU0sd0NBQXdDLENBQUM7QUFBQSxNQUMzRDtBQUdBLHFCQUFlLFFBQVEsRUFBRSxHQUFJLGVBQWUsU0FBUyxDQUFDLEdBQUksR0FBRyxNQUFNO0FBRW5FLFVBQUksZUFBZSxNQUFPLFFBQU87QUFFakMsVUFBSSxZQUFZO0FBQ2hCLHFCQUFlLFFBQVEsWUFBWSxZQUFZO0FBQzNDLFlBQUk7QUFDQSxnQkFBTSxZQUFZLE1BQU0sZ0JBQWdCO0FBQ3hDLGNBQUksQ0FBQyxXQUFXO0FBQ1osZ0JBQUksRUFBRSxhQUFhLEdBQUc7QUFDbEIsNEJBQWMsZUFBZSxLQUFLO0FBQ2xDLDZCQUFlLFFBQVE7QUFDdkIsc0JBQVEsTUFBTSw4Q0FBOEM7QUFBQSxZQUNoRTtBQUNBO0FBQUEsVUFDSjtBQUNBLGdCQUFNLFVBQVUsZUFBZTtBQUMvQix5QkFBZSxRQUFRO0FBQ3ZCLHdCQUFjLGVBQWUsS0FBSztBQUNsQyx5QkFBZSxRQUFRO0FBQ3ZCLGdCQUFNLFVBQVUsWUFBWSxPQUFPO0FBQ25DLGtCQUFRLE1BQU0scUNBQXFDLE9BQU87QUFBQSxRQUM5RCxTQUFTLEtBQUs7QUFDVixrQkFBUSxLQUFLLDZCQUE2QixHQUFHO0FBQUEsUUFDakQ7QUFBQSxNQUNKLEdBQUcsVUFBVTtBQUViLGFBQU87QUFBQSxJQUNYO0FBSUEscUJBQWlCLFFBQVEsY0FBYyxNQUFNO0FBQ3pDLFVBQUksQ0FBQyxJQUFJLE9BQU8sS0FBSyxRQUFNLEdBQUcsS0FBSyxTQUFTLFFBQVEsQ0FBQyxHQUFHO0FBQ3BELFlBQUk7QUFBRSwyQkFBaUI7QUFBQSxRQUFHLFFBQVE7QUFBQSxRQUFFO0FBQ3BDLHlCQUFpQjtBQUFNLGlCQUFTO0FBQU8sa0JBQVU7QUFDakQ7QUFBQSxNQUNKO0FBQ0EsaUJBQVcsV0FBVyxDQUFDO0FBQUEsSUFDM0IsQ0FBQztBQUVELGVBQVcsV0FBVyxDQUFDO0FBR3ZCLFVBQU0sSUFBSyxPQUFPLGlCQUFpQixjQUFjLGVBQWU7QUFFaEUsTUFBRSxrQkFBa0IsWUFBWTtBQUM1QixZQUFNLE9BQU8sTUFBTSxnQkFBZ0I7QUFDbkMsWUFBTSxPQUFPLE1BQU0sTUFBTSxJQUFJO0FBQzdCLGNBQVEsTUFBTSxxQkFBZ0IsSUFBSTtBQUNsQyxhQUFPO0FBQUEsSUFDWDtBQUVBLE1BQUUsa0JBQWtCLE9BQU8sUUFBUSxDQUFDLE1BQU07QUFDdEMsWUFBTSxPQUFPLE1BQU0sZ0JBQWdCO0FBQ25DLFVBQUksQ0FBQyxNQUFNO0FBQUUsZ0JBQVEsS0FBSyxzQkFBc0I7QUFBRyxlQUFPO0FBQUEsTUFBTTtBQUNoRSxZQUFNLEtBQUssWUFBWTtBQUFBLFFBQ25CLGFBQWE7QUFBQSxRQUNiLGFBQWE7QUFBQSxRQUNiLGNBQWM7QUFBQSxRQUNkLFlBQVksS0FBSyxJQUFJO0FBQUEsUUFDckIsR0FBRztBQUFBLE1BQ1AsQ0FBQztBQUNELGFBQU8sTUFBTSxLQUFLLElBQUk7QUFBQSxJQUMxQjtBQUVBLE1BQUUsZUFBZSxNQUFNLENBQUMsQ0FBRSxPQUFPLEdBQUc7QUFDcEMsTUFBRSxnQkFBZ0IsTUFBTTtBQUNwQixZQUFNLEtBQUssT0FBTztBQUNsQixhQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxJQUFJLG1CQUFtQjtBQUFBLElBQ2pFO0FBQUEsRUFDSixHQUFHOyIsCiAgIm5hbWVzIjogW10KfQo=
